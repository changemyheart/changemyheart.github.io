<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Github分支备份Hexo博客源文件]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[场景 Hexo 部署博客很方便，我的这个博客也是用 Hexo 部署在 GitHub Pages 上的，有得人可能在多台电脑上写博客，这个时候需要把博客的源文件备份在一个地方，这样只需把博客源文件复制下来就可以在另一个地方写博客并部署到 GitHub Pages上了 本篇介绍的就是利用博客的 repo 分支（ master 分支的必须用来存放你博客网站文件）托管 Hexo 源文件和配置达到备份的目的，下面开始正题 把博客目录的源文件push到repo分支上 cd 进入博客目录，Git 初始化： git init 完成之后，添加修改的文件，Hexo 就自带了 .gitignore 文件需要忽略的文件 都已经默认配置好了，add 全部文件： git add . 然后commit： git commit -m &quot;commit first time&quot; 提交成功之后，接下来就是 push 到github了，需要先把这 Hexo 源文件映射到远程 repo 上： git remote add origin https://github.com/your-name/your-name.github.io.git 接下来就是把Hexo源文件 push 上去，但是关键的地方到了，master上是 Hexo 生成博客网页的代码，而我们 Hexo 源文件是要 push 到一个分支上面的，所以接下来先要在 repo 上新建一个分支 新建一个叫做hexoSource的分支： git branch blogSource]]></content>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 12]]></title>
    <url>%2F2017%2F09%2F25%2Fpython3-learning-12%2F</url>
    <content type="text"><![CDATA[Objects In the last few chapters, we’ve been looking at different ways of organizing data and programs and collecting things together. We have seen that lists are a way to collect variables (data) together, and functions are a way to collect some code together into a unit that you can use over and over again. Objects take the idea of collecting things together one step further. Objects are a way to collect functions and data together. This is a very useful idea in programming, and it’s used in many, many programs. In fact, if you look under the hood in Python, almost everything is an object. In programming terms, we say Python is object oriented. That means that it’s possible (in fact, quite easy) to use objects in Python. It isn’t necessary to create your own objects, but it makes many things easier. In this chapter, we’ll learn what objects are and how to create and use them. In later chapters, when we start doing graphics, we’ll be using objects a lot. Objects in the real world What’s an object? If we were not talking about programming, and I asked you that question, we might have a conversation like this: That’s a good start at defining what an object is in Python, too. Take a ball, for example. You can do things to a ball, like pick it up, throw it, kick it, or inflate it (for some balls). We call these actions. You can also describe a ball by telling me its color, size, and weight. These are attributes of a ball. You can describe an object by describing its characteristics or attributes. One of the attributes of a ball is its shape. Most balls have a round shape. Other examples of attributes are color, size, weight, and cost. Another word for attributes is properties. Real objects in the real world have ■ things that you can do to them (actions). ■ things that describe them (attributes or properties). In programming, we have the same kind of thing. Objects in Python In Python, the characteristics, or “things you know” about an object, are also called attributes, so that should be easy to remember. In Python, the actions, or “things you can do” to an object, are called methods. If you were to make a Python version or model of a ball, the ball would be an object and it would have attributes and methods. The ball’s attributes would look like this: 123ball.colorball.sizeball.weight Those are all things you can describe about the ball. The ball’s methods would look like this: 123ball.kick()ball.throw()ball.inflate() Those are all things you can do to the ball. What are attributes? Attributes are all things you know (or can find out) about the ball. The ball’s attributes are chunks of information—numbers, strings, and so on. Sound familiar? Yes, they’re variables. They’re just variables that are included inside the object. You can display them: 1print(ball.size) You can assign values to them: 1ball.color = 'green' You can assign them to regular, non-object variables: 1myColor = ball.color You can also assign them to attributes in other objects: 1myBall.color = yourBall.color What are methods? Methods are things you can do with an object. They’re chunks of code that you can call to do something. Sound familiar? Yes, methods are just functions that are included inside the object. You can do all the things with methods that you can do with any other function, including passing arguments and returning values. Object = attributes + methods So objects are a way of collecting together attributes and methods (things you know, and things you can do) for a thing. Attributes are information, and methods are actions. What’s the dot? In our previous ball examples, you probably noticed the dot between the name of the object and the name of the attribute or method. That’s just the Python notation for using the attributes and methods of an object: object.attribute or object.method(). Simple as that. It’s called dot notation, and it’s used in many programming languages. Now we have the big picture about objects. Let’s start making some! Creating objects There are two steps to creating an object in Python. The first step is to define what the object will look like and act like—its attributes and methods. But creating this description doesn’t actually create an object. It’s kind of like the blueprints for a house. The blueprints tell you exactly what the house will look like, but a blueprint isn’t a house. You can’t live in a blueprint. You can just use it to build an actual house. In fact, you can use the blueprint to make many houses. In Python the description or blueprint of an object is called a class. The second step is to use the class to make an actual object. The object is called an instance of that class. Let’s look at an example of making a class and an instance. 123456class Ball: # This tells Python we’re making a class def bounce(self): if self.direction == "down": self.direction = "up" # This is a method In above, we have a class definition for a ball with one method: bounce(). But what about attributes? Well, attributes don’t really belong to the class, they belong to each instance. That’s because each instance can have different attributes. There are a couple of ways we can set the instance attributes. We’ll see both ways in the following sections. Creating an instance of an object As we mentioned before, a class definition isn’t an object. It’s just the blueprints. Now let’s build a house. If we want to create an instance of a Ball, we do it like this: 1&gt;&gt;&gt; myBall = Ball() Our ball does not have any attributes yet, so let’s give it some: 123&gt;&gt;&gt; myBall.direction = "down"&gt;&gt;&gt; myBall.color = "green"&gt;&gt;&gt; myBall.size = "small" This is one of the ways to define attributes for the object. We’ll see the other way in the next section. Now, let’s try out one of the methods. Here’s how we’d use the bounce() method: 1&gt;&gt;&gt; myBall.bounce() Let’s put this all together into a program, with some print statements to see what’s going on. 123456789101112131415161718192021222324class Ball: def bounce(self): if self.direction == "down": self.direction = "up"# Here’s our class, same as beforemyBall = Ball() # Makes an instance of our classmyBall.direction = "down"myBall.color = "red"myBall.size = "small"# Sets some attributes print("I just created a ball.") print("My ball is", myBall.size)print("My ball is", myBall.color)print("My ball's direction is", myBall.direction)print("Now I'm going to bounce the ball")# Prints the object’s attributesprint()myBall.bounce() # Uses a methodprint("Now the ball's direction is", myBall.direction) If we run the program above, we should see this: 123456789&gt;&gt;&gt; ========================== RESTART ==========================&gt;&gt;&gt; I just created a ball. My ball is smallMy ball is redMy ball&apos;s direction is downNow I&apos;m going to bounce the ball # Now we bounce() the ballNow the ball&apos;s direction is up # It changed direction, from down to up&gt;&gt;&gt; Notice that after we called the bounce() method, the ball’s direction changed from down to up, which is exactly what the code in the bounce() method is supposed to do. Initializing an object When we created our ball object, it didn’t have anything filled in for the size, color, or direction. We had to fill those in after we created the object. But there’s a way to set the properties of an object when it’s being created. This is called initializing the object. Initializing means “getting something ready at the start.” When we initialize something in software, we make it ready to use by getting it into the state or condition that we want. When you create the class definition, you can define a special method called __init__() that will run whenever a new instance of the class is created. You can pass arguments to the __init__() method to create the instance with its properties set however you want. 12345678910111213141516171819class Ball: def __init__(self, color, size, direction): self.color = color self.size = size self.direction = direction # Here’s the __init__() method def bounce(self): if self.direction == "down": self.direction = "up"myBall = Ball("red", "small", "down") # Attributes are passed in as arguments to __init__()print("I just created a ball.")print("My ball is", myBall.size)print("My ball is", myBall.color)print("My ball's direction is ", myBall.direction)print("Now I'm going to bounce the ball")print()myBall.bounce()print("Now the ball's direction is", myBall.direction) If you say print(myBall), you get something weird like this: &lt;__main__.Ball instance at 0x00BB83A0&gt; To change that, put in a method called __str__(). Make it return what you want printed. Then, every time you use print(myBall), it’ll say what you want. It’s one of the“magic” __xxxx__() class methods in Python! A “magic” method: __str__() Objects in Python have some “magic” methods. They’re not really magic, of course! They’re just some methods that Python includes automatically when youcreate any class. Python programmers usually call them special methods. We already saw the __init__() method that initializes an object when it’s created. Every object has an __init__() method built in. If you don’t put one in your class definition, the built-in one takes over, and all it does is create the object. Another special method is __str__(), which tells Python what to display when you print an object. By default, Python tells you ■ where the instance is defined (in Carter’s case __main__, which is the main part of the program). ■ the class name (Ball). ■ the memory location where the instance is being stored (that’s the 0x00BB83A0 part). But if you want print to display something different for your object, you can define your own __str__(), which will override the built-in one. 12345678910111213class Ball: def __init__(self, color, size, direction): self.color = color self.size = size self.direction = direction def __str__(self): msg = "Hi, I'm a " + self.size + " " + self.color + " ball!" return msg # Here’s the __str__() methodmyBall = Ball("red", "small", "down") print(myBall) Now, if we run the program above, here’s what we get: 1234&gt;&gt;&gt; ================= RESTART =================&gt;&gt;&gt; Hi, I&apos;m a small red ball!&gt;&gt;&gt; That looks a lot more friendly than &lt;__main__.Ball instance at 0x00BB83A0&gt;, don’t you think? What’s “self”? You might have noticed that the term “self” shows up in a few places in the class attributes and method definitions, like this: 1def bounce(self): What does self mean? Well, remember that we said you could use blueprints to build more than one house? You can also use a class to create more than one instance of an object, like this: 123cartersBall = Ball("red", "small", "down") warrensBall = Ball("green", "medium", "up")# Creating two instances of the Ball class When we call a method for one of these instances, like this, 1warrensBall.bounce() the method has to know which instance called it. Is it cartersBall that needs to bounce, or warrensBall? The self argument is what tells the method which object called it. It’s called the instance reference. But wait a minute! When we called the method, there was no argument in the parentheses of warrensBall.bounce(), but there’s a self argument in the method. Where did the self argument come from, if we didn’t pass anything? That’s another little bit of “magic” that Python does with objects. When you call a class method, the information about which instance called—the instance reference—is automatically passed to the method. It’s like writing this: 1Ball.bounce(warrensBall) In this case, we told the bounce() method which ball to bounce. In fact, this code will work too, because that is exactly what Python does behind the scenes when you write warrensBall.bounce(). By the way, the name self has no special meaning in Python. That’s just the name everybody uses for the instance reference. It’s another one of those conventions that make your code easier to read. You could name the instance variable whatever you want, but I strongly suggest you follow the convention and use self—it’ll make things much less confusing. An example class—HotDog For this example, we’ll assume that hot dogs always have a bun. (It’s too messy otherwise.) We’ll give our hot dog some attributes and some methods. These are the attributes: ■ cooked_level—A number that lets us know how long the hot dog has been cooked. We’ll use 0–3 for raw, over 3 for medium, over 5 for well-done, and anything over 8 will be charcoal! Our hot dogs will start out raw. ■ cooked_string—A string describing how well-done the hot dog is. ■ condiments—A list of what’s on the hot dog, like ketchup, mustard, and so on. These are the methods: ■ cook()—Cooks the hot dog for some period of time. This will make the hot dog more well-done. ■ add_condiment()—Adds condiments to the hot dog. ■ __init__()—Creates our instance and sets the default properties. ■ __str__()—Makes the print look nicer. First, we need to define the class. Let’s start with the __init__() method, which will set the default attributes for a hot dog: 12345class HotDog: def __init__(self): self.cooked_level = 0 self.cooked_string = "Raw" self.condiments = [] We start with a raw hot dog and no condiments. Now, let’s make a method to cook our hot dog: 1234567891011def cook(self, time): self.cooked_level = self.cooked_level + time # Increases the cooked level by the amount of time if self.cooked_level &gt; 8: self.cooked_string = "Charcoal" elif self.cooked_level &gt; 5: self.cooked_string = "Well-done" elif self.cooked_level &gt; 3: self.cooked_string = "Medium" else: self.cooked_string = "Raw" # Sets the strings for the different cooked levels Before we go any further, let’s test this part. First, we need to create an instance of a hot dog, and we’ll check the attributes, too. 1234myDog = HotDog()print(myDog.cooked_level)print(myDog.cooked_string)print(myDog.condiments) Let’s put this together into a program and run it. 12345678910111213141516171819class HotDog: def __init__(self): self.cooked_level = 0 self.cooked_string = "Raw" self.condiments = [] def cook(self, time): self.cooked_level = self.cooked_level + time if self.cooked_level &gt; 8: self.cooked_string = "Charcoal" elif self.cooked_level &gt; 5: self.cooked_string = "Well-done" elif self.cooked_level &gt; 3: self.cooked_string = "Medium" else: self.cooked_string = "Raw" myDog = HotDog()print(myDog.cooked_level)print(myDog.cooked_string)print(myDog.condiments) Another convention in Python is that the name of a class always starts with an uppercase (capital) letter. So far we have seen Ball and HotDog, so we have been following the convention. Now, run the code above and see what you get. It should look like this: 12345&gt;&gt;&gt; 0 # The cooked_levelRaw # The cooked_string[] # The condiments&gt;&gt;&gt; We see that the attributes are cooked_level = 0, cooked_string = &quot;Raw&quot;, and condiments is empty. Now, let’s test the cook() method. 12345print("Now I'm going to cook the hot dog") myDog.cook(4) # Cooks the hot dog for 4 minutesprint(myDog.cooked_level)print(myDog.cooked_string)# Checks the new cooked attributes Run the program again. Now, the output should look like this: 12345678&gt;&gt;&gt; 0Raw[]Now I'm going to cook the hot dog4Medium&gt;&gt;&gt; So our cook() method seems to work. The cooked_level went from 0 to 4, and the string updated too (from Raw to Medium). Let’s try adding some condiments. We need a new method for that. We could also add our __str__() function so it’ll be easier to print the object. Edit the program so it looks like following program. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class HotDog: def __init__(self): self.cooked_level = 0 self.cooked_string = "Raw" self.condiments = [] def __str__(self): msg = "hot dog" if len(self.condiments) &gt; 0: msg = msg + " with " for i in self.condiments: msg = msg+i+", " msg = msg.strip(", ") msg = self.cooked_string + " " + msg + "." return msg # Defines the new __str__() method def cook(self, time): self.cooked_level=self.cooked_level+time if self.cooked_level &gt; 8: self.cooked_string = "Charcoal" elif self.cooked_level &gt; 5: self.cooked_string = "Well-done" elif self.cooked_level &gt; 3: self.cooked_string = "Medium" else: self.cooked_string = "Raw" def addCondiment(self, condiment): self.condiments.append(condiment) # Defines the new add_condiments() methodmyDog = HotDog() # Creates the instanceprint(myDog)print("Cooking hot dog for 4 minutes...")myDog.cook(4)print(myDog)print("Cooking hot dog for 3 more minutes...")myDog.cook(3)print(myDog)print("What happens if I cook it for 10 more minutes?")myDog.cook(10)print(myDog)print("Now, I'm going to add some stuff on my hot dog")myDog.addCondiment("ketchup")myDog.addCondiment("mustard")print(myDog)# Tests to see if everything is working Run the program and see what you get. It should look like this: 123456789101112&gt;&gt;&gt; ================================ RESTART ================================&gt;&gt;&gt; Raw hot dog.Cooking hot dog for 4 minutes...Medium hot dog.Cooking hot dog for 3 more minutes...Well-done hot dog.What happens if I cook it for 10 more minutes?Charcoal hot dog.Now, I&apos;m going to add some stuff on my hot dogCharcoal hot dog with ketchup, mustard.&gt;&gt;&gt; The first part of the program creates the class. The second part tests the methods to cook our virtual hot dog and add some condiments. But judging by that last couple of lines, I think we cooked it too much. What a waste of ketchup and mustard! Hiding the data You might have realized that there are two ways we can view or change the data (attributes) inside an object. We can either access them directly, like this: 1myDog.cooked_level = 5 or we can use a method that modifies the attribute, like this: 1myDog.cook(5) If the hot dog started out raw (cooked_level = 0), these would both do the same thing. They’d set the cooked_level to 5. So why did we bother making a method to do this? Why not just do it directly? I can think of at least two reasons: ■ If we were accessing the attributes directly, then cooking the hot dog would require at least 2 parts: changing the cooked_level and changing the cooked_string. With a method, we just make one method call, and it does everything we need. ■ If we were accessing the attributes directly, we could do something like this: 1cooked_level = cooked_level - 2 That would make the hot dog less cooked than it was before. But you can’t uncook ahot dog! So that doesn’t make sense. Using a method, we can make sure that the cooked_level only increases and never decreases. In programming terms, restricting the access to an object’s data so you can only get it or change it by using methods is called data hiding. Python doesn’t have any way to enforce data hiding, but you can write code that follows this rule if you want to. So far, we have seen that objects have attributes and methods. We have seen how to create objects and how to initialize them with a special method called __init__(). We have also seen another special method called __str__() that makes our objects print more nicely. Polymorphism and inheritance Next, we’re going to look at the two aspects of objects that are probably the most important: polymorphism and inheritance. Those are two big long words, but they make objects very useful. I’ll clearly explain what they mean in the next sections. Polymorphism—same method, different behavior Very simply, polymorphism means that you can have two (or more) methods with the same name for different classes. These methods can behave differently, depending on which class they’re applied to. For example, let’s say you were making a program to practice geometry, and you needed to calculate the area of different shapes, like triangles and squares. You might create two classes, like this: 1234567891011121314class Triangle: def __init__(self, width, height): self.width = width self.height = height def getArea(self): area = self.width * self.height / 2.0 return areaclass Square: def __init__(self, size): self.size = size def getArea(self): area = self.size * self.size return area Both the Triangle class and the Square class have a method called getArea(). So if we had an instance of each class, like this, 12&gt;&gt;&gt; myTriangle = Triangle(4, 5)&gt;&gt;&gt; mySquare = Square(7) then we could calculate the area of either one using getArea(): 1234&gt;&gt;&gt; myTriangle.getArea()10.0&gt;&gt;&gt; mySquare.getArea()49 We used the method name getArea() for both shapes, but the method did something different for each shape. This is an example of polymorphism. Inheritance—learning from your parents In the real (nonprogramming) world, people can inherit things from their parents or other relatives. You can inherit traits like red hair, or you can inherit stuff like money or property. In object-oriented programming, classes can inherit attributes and methods from other classes. This allows you to have whole “families” of classes that share common attributes and methods. That way, you don’t have to start from scratch every time you want to add a member to the family. A class that inherits attributes or methods from another class is called a derived class or subclass. An example will help explain this. Imagine we’re making a game where the player can pick up various things along the way, like food, money, or clothing. We could make a class called GameObject. The GameObject class would have attributes like name (for example, “coin”, “apple”, or “hat”) and methods like pickUp() (which would add the coin to the player’s collection of objects). All game objects would have these common methods and attributes. Then, we could make a subclass for coins. The Coin class would be derived from GameObject. It would inherit the attributes and methods of GameObject, so the Coin class would automatically have a name attribute and a pickUp() method. The Coin class would also need a value attribute (how much the coin is worth) and a spend() method (so you could use the coin to buy something). Let’s see what the code might look like for these classes. 12345678910111213141516171819class GameObject: def __init__(self, name): self.name = name def pickUp(self, player): # put code here to add the object # to the player's collection # Defines GameObject classclass Coin(GameObject): # Coin is a subclass of GameObject def __init__(self, value): GameObject.__init__(self) # In __init__(), inherit GameObject’s init and add stuff to it self.value = value def spend(self, buyer, seller): # put code here to remove the coin # from the buyer's money and # add it to the seller's money # A new spend() method for the Coin class Thinking ahead In the last example, we didn’t put any real code in the methods, just some comments explaining what the methods would do. It’s a way of planning or thinking ahead for what you’ll add later. The actual code would depend on how the game worked. Programmers often do this as a way to organize their thoughts when they’re writing more complex code. The “empty” functions or methods are called code stubs. If you tried to run the previous example, you’d get an error, because a function definition can’t be empty. The Python pass keyword is used as a placeholder when you want to make a code stub. So the code should really look like this: 12345678910111213141516class Game_object: def __init__(self, name): self.name = name def pickUp(self): pass # put code here to add the object # to the player's collectionclass Coin(Game_object): def __init__(self, value): Game_object.__init__(self) self.value = value def spend(self, buyer, seller): pass # put code here to remove the coin # from the buyer's money and # add it to the seller's money I’m not going to give more detailed examples using objects, polymorphism, and inheritance in this chapter. We’ll see many examples of objects and how they’re used as we go through the rest of this book. You’ll get a much better understanding of how to use objects when we use them in real programs, like games. What did you learn? In this chapter, you learned about ■ what objects are. ■ attributes and methods. ■ what a class is. ■ creating an instance of a class. ■ special methods: __init__() and __str__(). ■ polymorphism. ■ inheritance. ■ code stubs. Test your knowledge What keywords do you use to define a new object type? What are attributes? What are methods? What’s the difference between a class and an instance? What name is usually used for the instance reference in a method? What’s polymorphism? What’s inheritance? Try it out Make a class definition for a BankAccount. It should have attributes for its name (a string), account number (a string or integer), and balance (a float). It should have methods to display the balance, make deposits, and make withdrawals. Make a class called InterestAccount that earns interest. It should be a subclass of BankAccount (so it inherits the attributes and methods). It should also have an attribute for interest rate, and a method to add interest. To keep things simple, assume that the addInterest() method will be called once each year to calculate the interest and update the balance.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《The American Accent Course 50 Rules You Must Know》]]></title>
    <url>%2F2017%2F09%2F25%2FThe-American-Accent-Course-50-Rules-You-Must-Know%2F</url>
    <content type="text"><![CDATA[Download links: VIDEO | The American Accent Course 50 Rules You Must Know]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 11]]></title>
    <url>%2F2017%2F09%2F24%2Fpython3-learning-11%2F</url>
    <content type="text"><![CDATA[Functions Pretty soon, our programs are going to start getting bigger and more complicated. We need some ways to organize them in smaller pieces so they’re easier to write and keep track of. There are three main ways to break programs into smaller parts. Functions are like building blocks of code that you can use over and over again. Objects are a way of describing pieces of your program as self-contained units. Modules are just separate files that contain parts of your program. In this chapter, we’ll learn about functions, and in the next two chapters, we’ll learn about objects and modules. Then we’ll have all the basic tools we need to start using graphics and sounds, and to create games. Functions—the building blocks In the simplest of terms, a function is just a chunk of code that does something. It’s a small piece that you can use to build a bigger program. You can put the piece together with other pieces, just like building something with toy blocks. You create or define a function with Python’s def keyword. You then use or call the function by using its name. Let’s start with a simple example. Creating a function The code in following defines a function and then uses it. This function prints a mailing address to the screen. 12345678def printMyAddress(): print("Warren Sande") print("123 Main Street") print("Ottawa, Ontario, Canada") print("K2M 2E9") print() printMyAddress() In line 1, we define a function, using the def keyword. We give the name of the function fol-lowed by parentheses “()” and then a colon: 1def printMyAddress(): I will explain what the parentheses are for soon. The colon tells Python that a block of code is coming next (just like for loops, while loops, and if statements). Then, we have the code that makes up the function. In the last line, we have the main program: we call the function by giving its name with the parentheses. This is where the program starts running. This one line makes the program run the code in the function that we just defined. When the main program calls a function, it’s like the function is helping the main program get its job done. The code inside the def block isn’t part of the main program, so when the program runs, it skips over that part and starts with the first line that isn’t inside a def block. The figure on the right shows what happens when you call a function. I added one extra line at the end of the program that prints a message after the function is done. These are the steps in the figure above: Start here. This is the beginning of the main program. When we call the function, we jump to the first line of code in the function. Execute each line of the function. When the function is finished, we continue where we left off in the main program. Calling a function Calling a function means running the code that is inside the function. If we define a function but never call it, that code will never run. We call a function by using its name and a set of parentheses. Sometimes there’s something in the parentheses and sometimes not. Try running the program above and see what happens. You should see something like this: 1234567&gt;&gt;&gt; =================== RESTART ===================&gt;&gt;&gt; Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9&gt;&gt;&gt; Now, that’s exactly the same output we’d have gotten from a simpler program that looks like this: 123456print("Warren Sande")print("123 Main Street")print("Ottawa, Ontario, Canada")print("K2M 2E9")print()&gt;&gt;&gt; So why did we go to the trouble of making things more complex and using a function? The main reason to use functions is that, once you have defined them, you can use them over and over again just by calling them. So if we wanted to print the address five times, we could do this: 12345printMyAddress()printMyAddress()printMyAddress()printMyAddress()printMyAddress() And the output would be 123456789101112131415161718192021222324Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9 You might say that you could do the same thing with a loop instead of a function. In this case, you could do the same thing with a loop. But if you wanted to print the address at different places in a program instead of all at once, a loop wouldn’t work. Another reason to use a function is that you can make it behave differently each time it runs. We’re going to see how to do that in the next section. Passing arguments to a function Now it’s time to see what the parentheses are for: arguments! In programming, the term argument means a piece of information you give to a function. We say that you pass the argument to the function. Imagine that you wanted to be able to use the address-printing function for any member of your family. The address would be the same for everybody, but the name would be different each time. Instead of having the name hard-coded as “Warren Sande” in the function, you can make it a variable. The variable is passed to the function when you call it. An example is the easiest way to see how this works. I modified the address-printing function to use one argument for the name. Arguments are named, just like other variables. I called this variable myName. When the function runs, the variable myName gets filled in with whatever argument we pass to the function when we call it. We pass the argument to the function by putting it inside the parentheses when we call the function. So, the argument myName is assigned the value “Carter Sande”. 12345678def printMyAddress(myName): # Passes myName argument to the function print(myName) # Prints the name print("123 Main Street") print("Ottawa, Ontario, Canada") print("K2M 2E9") print()printMyAddress("Carter Sande") # Passes “Carter Sande” as the argument to the function; the variable myName inside the function will have the value “Carter Sande” If we run the code, we get exactly what you’d expect: 1234567&gt;&gt;&gt; ===================== RESTART =====================&gt;&gt;&gt; Carter Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9&gt;&gt;&gt; This looks the same as the output we got from the first program, when we didn’t use arguments. But now, we can make the address print differently every time, like this: 1234printMyAddress("Carter Sande")printMyAddress("Warren Sande")printMyAddress("Kyra Sande")printMyAddress("Patricia Sande") And now, the output is different each time the function is called. The name changes, because we pass the function a different name each time. 123456789101112131415161718192021&gt;&gt;&gt; ========================== RESTART ==========================&gt;&gt;&gt; Carter Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Warren Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Kyra Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9Patricia Sande123 Main StreetOttawa, Ontario, CanadaK2M 2E9 Notice that whatever value we passed to the function was used inside the function and was printed as the name part of the address. What if I wanted to send letters to everyone on my street? The street numbers would have to be different every time. If there’s more than one thing that is different every time the function runs, you need more than one argument. That’s what we’re going to talk about next. Functions with more than one argument In code above, our function had a single argument. But functions can have more than one argument. In fact, they can have as many as you need. Let’s try an example with two arguments, and I think you’ll get the idea. Then you can keep adding as many arguments as you need for the functions in your programs. There’s another term you’ll hear when talking about passing things to a function: parameters. Some people say that the terms argument and parameter are interchangeable. So you could say, “I passed two parameters to that function,” or “I passed two arguments to that function.” Some people say that you should use argument when talking about the passing part (when you call the function), and parameter when talking about the receiving part (what is inside the function). As long as you use argument or parameter to talk about passing values to functions, programmers will know what you mean. To send Carter’s letters to everyone on the street, our address-printing function will need two arguments: one for the name, and one for the house number. 123456789101112def printMyAddress(someName, houseNum): print(someName) print(houseNum, end='') print("Main Street") print("Ottawa, Ontario, Canada") print("K2M 2E9") print()printMyAddress("Carter Sande", "45")printMyAddress("Jack Black", "64")printMyAddress("Tom Green", "22")printMyAddress("Todd White", "36") When we use multiple arguments (or parameters), we separate them with a comma, just like items in a list, which brings us to our next topic. . . . How many is too many? I said before that you can pass as many arguments as you want to a function. That is true, but if your function has more than five or six arguments, it might be time to think of doing things another way. One thing you can do is collect all the arguments in a list and then pass the list to the function. That way, you’re passing a single variable (the list variable), which just happens to contain a bunch of values. It might make your code easier to read. Functions that return a value So far, our functions have just been doing stuff for us. But a very useful thing about functions is that they can also send you something back. We have seen that you can send information (arguments) to functions, but functions can also send information back to the caller. The value that comes back from a function is called the result or return value. Returning a value The way you make a function return a value is to use the Python return keyword inside the function. Here’s an example: 123def calculateTax(price, tax_rate): taxTotal = price + (price * tax_rate) return taxTotal This will send the value taxTotal back out to the part of the program that called the function. But when it is sent back, where does it go? Returned values go back to whatever code called the function. Here’s an example: 1totalPrice = calculateTax(7.99, 0.06) The calculateTax function will return the value 8.4694, and that value will be assigned to totalPrice. You can use a function to return values anywhere you’d use an expression. You can assign the return value to a variable (as we just did), use it in another expression, or printit, like this: 123print(calculateTax(7.99, 0.06))8.4694total = calculateTax(7.99, 0.06) + calculateTax(6.59, 0.08) You can also do nothing with the returned value, like this: 1calculateTax(7.49, 0.07) In the last example, the function ran and calculated the total with tax, but we didn’t use the result. Let’s make a program with a function that returns a value. In following, the calculateTax() function returns a value. You give it the price before tax and the tax rate, and it returns the price after tax. We’ll assign this value to a variable. So instead of just using the function’s name like we did before, we need a variable, an equal sign (=), and then the function’s name. The variable will be assigned the result that the calculateTax() function gives back. 12345678def calculateTax(price, tax_rate): total = price + (price * tax_rate) return total # Sends result back to the main programmy_price = float(raw_input ("Enter a price: "))totalPrice = calculateTax(my_price, 0.06) # Calls function and stores the result in totalPriceprint("price = ", my_price, " Total price = ", totalPrice) Try typing in, saving, and running the program above. Notice that the tax rate is fixed as 0.06 (which equals 6 percent tax) in the code. If the program had to handle different tax rates, you could have the user enter the tax rate as well as the price. Variable scope You might have noticed that we have variables outside the function, like totalPrice, as well as variables inside the function, like total. These are just two names for the same thing. It’s just like back in chapter 2, when we had YourTeacher = MyTeacher. In our calculateTax example, totalPrice and total are two tags attached to the same thing. With functions, the names inside the function are only created when the function runs. They don’t even exist before the function runs or after it has finished running. Python has something called memory management that does this automatically. Python creates new names to use inside the function when it runs, and then deletes them when the function is finished. That last part is important: when the function is done running, any names inside it cease to exist. While the function is running, the names outside the function are sort of on hold—they’re not being used. Only the names inside the function are being used. The part of a program where a variable is used (or available to be used) is called its scope. Local variables In last program, the variables price and total were only used within the function. We say that price, total, and tax_rate are in the scope of the calculateTax() function. Another term that is used is local. The price, total, and tax_rate variables are local variables in the calculateTax() function. One way to see what this means is to add a line to the program above that tries to print the value of price somewhere outside the function. 12345678910def calculateTax(price, tax_rate): total = price + (price * tax_rate) return total # Defines a function to calculate tax and return the totalmy_price = float(input ("Enter a price: "))\totalPrice = calculateTax(my_price, 0.06) # Calls the function and stores and prints the resultprint("price = ", my_price, " Total price = ", totalPrice)print(price) # Tries to print price If you run this, you’ll get an error that looks like this: 1234Traceback (most recent call last): File "C:/.../Listing_13-5.py", line 11, in &lt;module&gt; print priceNameError: name 'price' is not defined The last line of the error message tells the story: when we’re not inside the calculateTax() function, the variable price is not defined. It only exists while the function is running. When we tried to print the value of price from outside the function (when the function was not running), we got an error. Global variables In contrast to the local variable price, the variables my_price and totalPrice in last program are defined outside the function, in the main part of the program. We use the term global for a variable that has a wider scope. In this case, wider means the main part of the program, not what’s inside the function. If we expanded the program in listing 13.5, we could use the variables my_price and totalPrice in another place in the program, and they would still have the values we gave them earlier. They would still be in scope. Because we can use them anywhere in the program, we say they’re global variables. When we were outside the function and tried to print a variable that was inside the function, we got an error. The variable didn’t exist; it was out of scope. What do you think will happen if we do the opposite: try to print a global variable from inside the function? Following program tries to print the variable my_price from inside the calculateTax() function. Try it and see what happens. 123456789def calculateTax(price, tax_rate): total = price + (price * tax_rate) print(my_price) # Tries to print my_price return totalmy_price = float(input ("Enter a price: "))totalPrice = calculateTax(my_price, 0.06) print("price = ", my_price, " Total price = ", totalPrice) Did it work? Yes! But why? When we started talking about variable scope, I told you that Python uses memory management to automatically create local variables when a function runs. The memory manager does some other things, too. In a function, if you use a variable name that has been defined in the main program, Python will let you use the global variable as long as you don’t try to change it. So you can do this: 1print(my_price) or this: 1your_price = my_price because neither of these changes my_price. If any part of the function tries to change the variable, Python creates a new local variable instead. So if you do this, 1my_price = my_price + 10 then my_price is a new local variable that Python creates when the function runs. In the example above, the value that was printed was the global variable my_price, because the function didn’t change it. The program in listing 13.7 shows you that, if you do try to change the global variable inside the function, you get a new, local variable instead. Try running it and see. 12345678910111213def calculateTax(price, tax_rate): total = price + (price * tax_rate) my_price = 10000 # Modifies my_price inside the function print("my_price (inside function) = ", my_price) # Prints the local version of my_price [First my_price] return totalmy_price = float(input("Enter a price: "))totalPrice = calculateTax(my_price, 0.06)print("price = ", my_price, " Total price = ", totalPrice)print("my_price (outside function) = ", my_price) # Prints the global version of my_price [Second my_price]# The [First my_price] is a different chunk of memory than the [Second my_price] If you run the code above, the output will look like this: 1234567&gt;&gt;&gt; ========================== RESTART ==========================&gt;&gt;&gt; Enter a price: 7.99my_price (inside function) = 10000 price = 7.99 Total price = 8.4694my_price (outside function) = 7.99&gt;&gt;&gt; As you can see, there are now two different variables called my_price, with different values. One is the local variable inside the calculateTax() function that we set to 10,000. The other is the global variable we defined in the main program to capture the user’s input, which was 7.99. Forcing a global In the last section, we saw that, if you try to change the value of a global variable from inside a function, Python creates a new local variable instead. This is meant to prevent functions from accidentally changing global variables. However, there are times when you want to change a global variable from inside a function. So how do you do it? Python has a keyword, global, that lets you do that. You use it like this: 12def calculateTax(price, tax_rate): global my_price If you use the global keyword, Python won’t make a new local variable called my_price. It will use the global variable my_price. If there’s no global variable called my_price, it will cre-ate one. A bit of advice on naming variables We saw in the previous sections that you can use the same names for global variables and local variables. Python will automatically create new local variables when it needs to, or you can prevent that with the global keyword. However, I strongly recommend that you don’t reuse names. As you might have noticed from some of the examples, it can be difficult to know whether the variable is the local version or the global version. It makes the code more confusing, because you have different variables with the same name. And wherever there’s confusion, bugs love to creep in. So for now, I recommend you use different names for local variables and global variables. That way, there’s no confusion, and you’ll keep the bugs at bay. What did you learn? In this chapter, you learned ■ what a function is. ■ what arguments (or parameters) are. ■ how to pass an argument to a function. ■ how to pass multiple arguments to a function. ■ how to make a function return a value to the caller. ■ what variable scope is, and what local and global variables are. ■ how to use global variables in a function. Test your knowledge What keyword do you use to create a function? How do you call a function? How do you pass information (arguments) to a function? What’s the maximum number of arguments a function can have? How do you get information back from a function? What happens to local variables in a function after the function is finished running? Try it out Write a function to print your name in big letters, like this: Write a program that calls the function a number of times. Make a function that will allow you to print any name, address, street, city, state or province, zip or postal code, and country in the world. (Hint: It needs seven arguments. You can pass them as individual arguments or as a list.) Try using the example from listing 13.7, but making my_price global so you can see the difference in the resulting output. Write a function to calculate the total value of some change—quarters, dimes, nickels, and pennies (just like in the last “Try it out” question from chapter 5). The function should return the total value of the coins. Then write a program that calls the function. The output should look like this when it runs: quarters: 3 dimes: 6 nickels: 7 pennies: 2 total is $1.72]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 10]]></title>
    <url>%2F2017%2F09%2F22%2Fpython3-learning-10%2F</url>
    <content type="text"><![CDATA[Collecting Things Together—Lists We’ve seen that Python can store things in its memory and retrieve them, using names. So far, we have stored strings and numbers (both integers and floats). Sometimes it’s useful to store a bunch of things together in a kind of “group” or “collection.” Then you can do things to the whole collection at once and keep track of groups of things more easily. One of the kinds of collections is a list. In this chapter, we’re going to learn about lists—what they are and how to create, modify, and use them. Lists are very useful, and they’re used in many, many programs. We’ll use a lot of them in the examples in upcoming chapters when we start doing graphics and game programming, because the many graphical objects in a game are often stored in a list. What’s a list? In Python, you’d write this: 1family = ['Mom', 'Dad', 'Junior', 'Baby'] or: 1luckyNumbers = [2, 7, 14, 26, 30] Both family and luckyNumbers are examples of Python lists, and the individual things inside lists are called items. As you can see, lists in Python aren’t much different from lists you make in everyday life. Lists use square brackets to show where the list starts and ends, and they use commas to separate the items inside. Creating a list Both family and luckyNumbers are variables. We said before that you can assign different kinds of values to variables. We have already used them for numbers and strings, and they can also be assigned a list. You create a list like you create any other variable—by assigning something to it, just like we did with luckyNumbers. You can also create an empty list, like this: 1newList = [] There are no items inside the square brackets, so the list is empty. But what good is an empty list? Why would we want to create one? Well, quite often, we don’t know ahead of time what’s going to be in the list. We don’t know how many items will be in it, or what those items will be. We just know we’ll be using a list to hold them. Once we have an empty list, the program can add things to it. So how do we do that? Adding things to a list To add things to a list, you use append(). Try this in interactive mode: 123&gt;&gt;&gt; friends = [] #Makes a new, empty list&gt;&gt;&gt; friends.append('David') #Adds an item, "David", to the list&gt;&gt;&gt; print(friends) You’ll get this result: 1['David'] Try adding another item: 123&gt;&gt;&gt; friends.append('Mary')&gt;&gt;&gt; print(friends)['David', 'Mary'] Remember that you have to create the list (empty or not) before you start adding things to it. It’s like if you are making a cake: you can’t just start pouring ingredients together—you have to get a bowl out first to pour them into. Otherwise you’ll end up with stuff all over the counter! What’s the dot? Why did we use a dot between friends and append()? Well, that starts getting into a pretty big topic: objects. Many things in Python are objects. To do something with an object, you need the object’s name (the variable name), then a dot, and then whatever you want to do to the object. So to append something to the friends list, you’d write this: 1friends.append(something) Lists can hold anything Lists can hold any kind of data that Python can store. That includes numbers, strings, objects, and even other lists. The items in a list don’t have to be the same type or kind of thing. That means a single list can hold both numbers and strings, for example. A list could look like this: 1my_list = [5, 10, 23.76, 'Hello', myTeacher, 7, another_list] Let’s make a new list with something simple, like the letters of the alphabet, so it’s easier to see what’s going on as we learn about lists. Type this in interactive mode: 1&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e'] Getting items from a list You can get single items from a list by their index number. The list index starts from 0, so the first item in our list is letters[0]. 12&gt;&gt;&gt; print(letters[0])a Let’s try another one: 12&gt;&gt;&gt; print(letters[3])d Why does the index start from 0, not 1? That’s a question that a lot of programmers, engineers, and computer scientists have argued about since computers were invented. I’m not going to get in the middle of that argument, so let’s just say the answer is “because,” and move on . . . Okay, okay! Have a look at “WHAT’S GOING ON IN THERE” to see an explanation of why the index starts at 0 instead of 1. Remember that computers use binary digits or bits to store everything. Back in the old days, those bits were expensive. Each one had to be hand-picked and carried by donkey from the bit plantation…just kidding.But they were expensive. Binary counting starts at 0. So, to make the most efficient use of the bits and not waste any, things like memory locations and list indices started at 0 as well. You’ll quickly get used to indices starting at 0. It’s very common in programming. “Slicing” a list You can also use indices to get more than one item from a list at a time. This is called slicing a list. 12&gt;&gt;&gt; print letters[1:4]['b', 'c', 'd'] Similar to the range() in our for loops, slicing gets the items starting with the first index, but stops before getting to the second index. That’s why we got back three items, not four, in the previous example. One way to remember this is that the number of items you get back is always the difference between the two index numbers. (4 – 1 = 3, and we got three items back.) Here’s one other thing that is important to remember about slicing a list: What you get back when you slice a list is another (usually smaller) list. This smaller list is called a slice of the original list. The original list isn’t changed. The slice is a partial copy of the original. Look at the difference here: 1234&gt;&gt;&gt; print(letters[1])b&gt;&gt;&gt; print(letters[1:2])['b'] In the first case, we got back an item. In the second case, we got back a list containing the item. It’s a subtle difference, but you need to know about it. In the first case, we used a sin-gle index to get one item out of the list. In the second case, we used slice notation to get a one-item slice of the list. To really see the difference, try this: 1234&gt;&gt;&gt; print(type(letters[1]))&lt;type 'str'&gt;&gt;&gt;&gt; print(type(letters[1:2]))&lt;type 'list'&gt; Displaying the type of each one tells you for certain that in one case you get a single item (a string, in this case), and in the other case you get a list. The smaller list you get back when you slice a list is a copy of items from the original list. That means you can change it and the original list won’t be affected. Slice shorthand There are some shortcuts you can take when using slices. They don’t really save you much typing, but programmers are a lazy bunch, so they use shortcuts a lot. I want you to know what the shortcuts are, so you can recognize them when you see them in other people’s code and understand what’s going on. That’s important, because looking at other people’s code and trying to understand it is a good way to learn a new programming language, or programming in general. If the slice you want includes the start of the list, the shortcut is to use a colon followed by the number of items you want, like this: 12&gt;&gt;&gt; print(letters[:2])['a', 'b'] Notice that there is no number before the colon. This will give you everything from the start of the list up to (but not including) the index you specify. You can do something similar to get the end of a list: 12&gt;&gt;&gt; letters[2:]['c', 'd', 'e'] Using a number followed by a colon gives you everything from the index you specify to the end of the list. If you don’t put any numbers in, and just use a colon, you get the whole list: 12&gt;&gt;&gt; letters[:]['a', 'b', 'c', 'd', 'e'] Remember that I said that slices make a copy of the original? So letters[:] makes a copy of the whole list. This is handy if you want to make some changes to a list but keep the original unchanged. Modifying items You can use the index to change one of the list items: 12345&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; letters[2] = 'z'&gt;&gt;&gt; print(letters)['a', 'b', 'z', 'd', 'e'] But you can’t use the index to add new items to the list. Right now, there are five items in the list, with indices from 0 to 4. So we could not do something like this: It would not work. (Try it if you want.) It’s like trying to change something that isn’t there yet. To add items to a list, you have to do something else, and that’s where we’re going next. But before we do, let’s change our list back to the way it was: 123&gt;&gt;&gt; letters[2] = 'c'&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e'] Other ways of adding to a list We already saw how to add things to a list using append(). But there are other ways. In fact, there are three methods for adding things to a list: append(), extend(), and insert(). ■ append() adds one item to the end of the list. ■ extend() adds multiple items to the end of the list. ■ insert() adds one item somewhere in the list, not necessarily at the end. You tell it where to add the item. Adding to the end: append() We already saw how append() works. It adds one item to the end of a list: 123&gt;&gt;&gt; letters.append('n')&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e', 'n'] Let’s add one more: 123&gt;&gt;&gt; letters.append('g')&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e', 'n', 'g'] Notice that the letters are not in order. That’s because append() adds the item to the end of the list. If we want the items in order, we’ll have to sort them. We’ll get to sorting very soon. Extending the list: extend() extend() adds several items to the end of a list: 123&gt;&gt;&gt; letters.extend(['p', 'q', 'r'])&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e', 'n', 'g', 'p', 'q', 'r'] Notice that what’s inside the round brackets of the extend() method is a list. A list has square brackets, so for extend(), you could have both round and square brackets. Everything in the list you give to extend() gets added to the end of the original list. Inserting an item: insert() insert() adds a single item somewhere in the list. You tell it at what position in the list you want the item added: 123&gt;&gt;&gt; letters.insert(2, 'z')&gt;&gt;&gt; print(letters)['a', 'b', 'z', 'c', 'd', 'e', 'n', 'g', 'p', 'q', 'r'] Here, we added the letter z at index 2. Index 2 is the third position in the list (because the indices start at 0). The letter that used to be in the third position, c, got bumped over by one place, to the fourth position. Every other item in the list also got bumped one position. The difference between append() and extend() Sometimes append() and extend() look very similar, but they do different things. Let’s go back to our original list. First, try using extend() to add three items: 1234&gt;&gt;&gt; letters = ['a','b','c','d','e']&gt;&gt;&gt; letters.extend(['f', 'g', 'h'])&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] Now, we’ll try to use append() to do the same thing: 1234&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; letters.append(['f', 'g', 'h'])&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e', ['f', 'g', 'h']] What happened here? Well, we said before that append() adds one item to a list. How did it add three? It didn’t. It added one item, which happens to be another list containing three items. That’s why we got the extra set of square brackets inside our list. Remember that a list can hold anything, including other lists. That’s what we’ve got. insert() works the same way as append(), except that you tell it where to put the new item. append() always puts it at the end. Deleting from a list How do we delete or remove things from a list? There are three ways: remove(), del, and pop(). Deleting with remove() remove() deletes the item you choose from the list and throws it away: 1234&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; letters.remove('c')&gt;&gt;&gt; print(letters)['a', 'b', 'd', 'e'] You don’t need to know where in the list the item is. You just need to know it’s there somewhere. If you try to remove something that isn’t in the list, you’ll get an error: 12345&gt;&gt;&gt; letters.remove('f')Traceback (most recent call last): File "&lt;pyshell#32&gt;", line 1, in -toplevel- letters.remove('f')ValueError: list.remove(x): x not in list So how can you find out if a list contains a certain item? That’s coming right up. First, let’s look at the other ways to delete something from a list. Deleting with del del lets you delete an item from the list using its index, like this: 1234&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; del letters[3]&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'e'] Here, we deleted the fourth item (index 3), which was the letter d. Deleting with pop() pop() takes the last item off the list and gives it back to you. That means you can assign it a name, like this: 123456&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; lastLetter = letters.pop()&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd']&gt;&gt;&gt; print(lastLetter)e You can also use pop() with an index, like this: 1234567&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; second = letters.pop(1)&gt;&gt;&gt; print(second)b&gt;&gt;&gt; print(letters)['a', 'c', 'd', 'e']e Here, we popped the second letter (index 1), which was b. The item we popped was assigned to second, and it was also removed from letters. With nothing inside the parentheses, pop() gives you the last item and removes it from the list. If you put a number in the parentheses, pop(n) gives you the item at that index and removes it from the list. Searching a list Once we have several items in a list, how do we find them? Two things you’ll often need to do with a list are ■ find out whether an item is in a list or not. ■ find out where an item is in the list (its index). The in keyword To find out whether something is in a list, you use the in keyword, like this: 1234if 'a' in letters: print("found 'a' in letters")else: print("didn't find 'a' in letters") The 'a' in letters part is a Boolean or logical expression. It’ll return the value True if a is in the list, and False otherwise. You can try this in interactive mode: 1234&gt;&gt;&gt; 'a' in lettersTrue&gt;&gt;&gt; 's' in lettersFalse This is telling us that the list called letters does have an item a, but it does not have an item s. So a is in the list, and s isn’t in the list. Now you can combine in and remove(), and write something that won’t give you an error, even if the value isn’t in the list: 12if 'a' in letters: letters.remove('a') This code only removes the value from the list if the value is in the list. Finding the index To find where in the list an item is located, you use the index() method, like this: 123&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; print(letters.index('d'))3 So we know that d has index 3, which means it’s the fourth item in the list. Just like remove(), index() will give you an error if the value isn’t found in the list, so it’s a good idea to use it with in, like this: 12if 'd' in letters: print(letters.index('d')) Looping through a list When we first talked about loops, we saw that loops iterate through a list of values. We also learned about the range() function and used it as a shortcut for generating lists of num-bers for our loops. You saw that range() gives you a list of numbers. But a loop can iterate through any list—it doesn’t have to be a list of numbers. Let’s say we wanted to print our list of letters with one item on each line. We could do something like this: 12345678910&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; for letter in letters: print(letter) abcde&gt;&gt;&gt; This time, our loop variable is letter. (Before, we used loop variables like looper or i, j, and k.) The loop iterates over (loops through) all the values in the list, and each time through, the current item is stored in the loop variable, letter, and then is displayed. Sorting lists Lists are an ordered type of collection. This means the items in a list have a certain order, and each one has a place, its index. Once you have put items in a list in a certain order, they stay in that order unless you change the list with insert(), append(), remove(), or pop(). But that order might not be the order you want. You might want a list sorted before you use it. To sort a list, you use the sort() method. 123456&gt;&gt;&gt; letters = ['d', 'a', 'e', 'c', 'b']&gt;&gt;&gt; print(letters)['d', 'a', 'e', 'c', 'b']&gt;&gt;&gt; letters.sort()&gt;&gt;&gt; print(letters)&gt;&gt;&gt; ['a', 'b', 'c', 'd', 'e'] sort() automatically sorts strings alphabetically and numbers numerically, from smallest to largest. It’s important to know that sort() modifies the list in place. That means it changes the original list you give it. It does not create a new, sorted list. That means you can’t do this: 1&gt;&gt;&gt; print(letters.sort()) If you do, you’ll get “None.” You have to do it in two steps, like this: 12&gt;&gt;&gt; letters.sort()&gt;&gt;&gt; print(letters) Sorting in reverse order There are two ways to get a list sorted in reverse order. One is to sort the list the normal way, and then reverse the sorted list, like this: 1234567&gt;&gt;&gt; letters = ['d', 'a', 'e', 'c', 'b']&gt;&gt;&gt; letters.sort()&gt;&gt;&gt; print(letters)['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; letters.reverse()&gt;&gt;&gt; print(letters)['e', 'd', 'c', 'b', 'a'] Here we saw a new list method called reverse(), which reverses the order of items in a list. The other way is to add a parameter to sort() to make it sort in descending order (from largest to smallest). 1234&gt;&gt;&gt; letters = ['d', 'a', 'e', 'c', 'b']&gt;&gt;&gt; letters.sort (reverse = True)&gt;&gt;&gt; print(letters)['e', 'd', 'c', 'b', 'a'] The parameter is called reverse, and it does exactly what you’d expect—it makes the list sort in reverse order. Remember that all of the sorting and reversing we just talked about modifies the original list. That means your original order is lost. If you want to preserve the original order and sort a copy of the list, you could use slice notation, which we talked about earlier in this chapter, to make a copy—another list equal to the original: 1234567&gt;&gt;&gt; original_list = ['Tom', 'James', 'Sarah', 'Fred']&gt;&gt;&gt; new_list = original_list[:]&gt;&gt;&gt; new_list.sort()&gt;&gt;&gt; print(original_list)['Tom', 'James', 'Sarah', 'Fred']&gt;&gt;&gt; print(new_list)['Fred', 'James', 'Sarah', 'Tom'] We sorted new, but original also got sorted, because new and original are just two different names for the same list. There are not two different lists. This means that, if you really want to make a copy of a list, you need to do something different from new = original. The easiest way to do this is to use slice notation, like I did above: new = original[:]. This means “copy everything in the list, from the first item to the last item.” There are now two separate lists. We made a copy of the original and called it new. Now if we sort one list, the other one won’t be sorted. Another way to sort—sorted() There is another way to get a sorted copy of a list without changing the order of the original list. Python has a function called sorted() for that purpose. It works like this: 123456&gt;&gt;&gt; original = [5, 2, 3, 1, 4]&gt;&gt;&gt; newer = sorted(original)&gt;&gt;&gt; print(original)[5, 2, 3, 1, 4]&gt;&gt;&gt; print(newer)[1, 2, 3, 4, 5] The sorted() function gives you a sorted copy of the original list. Mutable and immutable If you remember back to chapter 2, we said that you couldn’t actually change a number or string, you could only change what number or string a name was assigned to (in other words, move the tag). But lists are one of the types in Python that can be changed. As we just saw, lists can have items appended or deleted, and the items can be sorted or reversed. These two different kinds of variables are called mutable and immutable. Mutable just means “able to be changed” or “changeable.” Immutable means “not able to be changed” or “unchangeable.” In Python, numbers and strings are immutable (cannot be changed), and lists are mutable (can be changed). Tuple—an immutable list There are times when you don’t want a list to be changeable. So, is there an immutable kind of list in Python? The answer is yes. There is a type called a tuple, which is exactly that, an immutable (unchangeable)list. You make one like this: 1my_tuple = ("red", "green", "blue") You use round brackets, instead of the square ones that lists use. Because tuples are immutable (unchangeable), you can’t do things like sort them or append or delete items. Once you create a tuple with a set of items, it stays that way. Lists of lists: tables of data When thinking about how data is stored in a program, it’s useful to visualize it. A variable has a single value. [myTeacher &gt;&gt;&gt; Mr. Wilson] A list is like a row of values strung together. [myFriends &gt;&gt;&gt; Kim Curtis Shaun Jenn Karla] Sometimes you need a table with rows and columns. How can we save a table of data? We already know that we can make a list to hold several items. We could put each student’s marks in a list, like this: 123&gt;&gt;&gt; joeMarks = [55, 63, 77, 81]&gt;&gt;&gt; tomMarks = [65, 61, 67, 72]&gt;&gt;&gt; bethMarks = [97, 95, 92, 88] or we could use a list for each subject, like this: 1234&gt;&gt;&gt; mathMarks = [55, 65, 97]&gt;&gt;&gt; scienceMarks = [63, 61, 95]&gt;&gt;&gt; readingMarks = [77, 67, 92]&gt;&gt;&gt; spellingMarks = [81, 72, 88] But we might want to collect all the data together in a single data structure. A data structure is a way of collecting, storing, or representing the data in a program. Data structures can include variables, lists, and some other things we haven’t talked about yet. The term data structure really refers to the way the data is organized in a program. To make a single data structure for our class marks, we could do something like this: 123&gt;&gt;&gt; classMarks = [joeMarks, tomMarks, bethMarks]&gt;&gt;&gt; print(classMarks)[[55, 63, 77, 81], [65, 61, 67, 72], [97, 95, 92, 88]] This gives us a list of items, where each item is itself a list. We have created a list of lists. Each of the items in the classMarks list is itself a list. We could also have created classMarks directly, without first creating joeMarks, tomMarks, and bethMarks, like this: 123&gt;&gt;&gt; classMarks = [ [55,63,77,81], [65,61,67,72], [97,95,92,88] ]&gt;&gt;&gt; print(classMarks)[[55, 63, 77, 81], [65, 61, 67, 72], [97, 95, 92, 88]] Now let’s try displaying our data structure. classMarks has three items, one for each student. So we can just loop through them using in: 123456&gt;&gt;&gt; for studentMarks in classMarks: print(studentMarks) [55, 63, 77, 81][65, 61, 67, 72][97, 95, 92, 88] Here we looped through the list called classMarks. The loop variable is studentMarks. Each time through the loop, we print one item in the list. That one item is the marks for a single student, which is itself a list. (We created the student lists above.) Notice that this looks very similar to the table on the previous page. So we have come up with a data structure to hold all our data in one place. Getting a single value from the table How do we get access to values in this table (our list of lists)? We already know that the first student’s marks (joeMarks) are in a list that is the first item in classMarks. Let’s check that: 12&gt;&gt;&gt; print(classMarks[0])[55, 63, 77, 81] classMarks[0] is a list of Joe’s marks in the four subjects. Now we want a single value from classMarks[0]. How do we do that? We use a second index. If we want the third of his marks (his Reading mark), which has index 2, we’d do this: 12&gt;&gt;&gt; print(classMarks[0][2])77 This gave us the first item in classMarks (index 0), which was the list of Joe’s marks, and the third item in that list (index 2), which was his Reading mark. When you see a name with two sets of square brackets, like classMarks[0][2], that is usually referring to a list of lists. The classMarks list doesn’t really know about the names Joe, Tom, and Beth, or the subjects Math, Science, Reading, and Spelling. We labeled them that way because we know what we intended to store in the list. But to Python, they’re just numbered places in a list. This is just like the numbered mailboxes at a post office. They don’t have names on them, just numbers. The postmaster keeps track of what belongs where, and you know which box is yours. A more accurate way to label the classMarks table would be like this: Now it’s easier to see that the mark 77 is stored in classMarks[0][2]. If we were writing a program using classMarks to store our data, we’d have to keep track of which data was stored in which row and column. Just like the postmaster, we’d have the job of keeping track of which slot belongs to which piece of data. What did you learn? In this chapter, you learned ■ what lists are. ■ how to add things to a list. ■ how to delete things from a list. ■ how to find out if a list contains a certain value. ■ how to sort a list. ■ how to make a copy of a list. ■ about tuples. ■ about lists of lists. Test your knowledge What are two ways to add something to a list? What are two ways to remove something from a list? What are two ways to get a sorted copy of a list, without changing the original list? How do you find out whether a certain value is in a list? How do you find out the location of a certain value in a list? What’s a tuple? How do you make a list of lists? How do you get a single value from a list of lists? Try it out Write a program to ask the user for five names. The program should store the names in a list, and print them all out at the end. It should look something like this: 1234567Enter 5 names:TonyPaulNickMichelKevinThe names are Tony Paul Nick Michel Kevin Modify the program from question #1 to print both the original list of names and a sorted list. Modify the program from question #1 to display only the third name the user typed in, like this: 1The third name you entered is: Nick Modify the program from question #1 to let the user replace one of the names. She should be able to choose which name to replace, and then type in the new name. Finally, display the new list like this: 12345678910Enter 5 names:TonyPaulNickMichelKevinThe names are Tony Paul Nick Michel KevinReplace one name. Which one? (1-5): 4New name: PeterThe names are Tony Paul Nick Peter Kevin]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 09]]></title>
    <url>%2F2017%2F09%2F21%2Fpython3-learning-09%2F</url>
    <content type="text"><![CDATA[Nested and Variable Loops We already saw that, within the body of a loop (which is a block of code), we can put other things that have their own blocks. If you look at the number-guessing program, you’ll see this: The outer, light gray block is a while loop block, and the dark gray blocks are if and elif blocks within that while loop block. You can also put a loop within another loop. These loops are called nested loops. Nested loops What if we wanted to print three multiplication tables at once? That’s the kind of thing a nested loop is perfect for. A nested loop is one loop inside another loop. For each iteration of the outer loop, the inner loop goes through all of its iterations. To print three multiplication tables, we’d just enclose the original loop (which prints a single multiplication table) in an outer loop (which runs three times). This makes the program print three tables instead of one. 1234for multiplier in range (5, 8): | This outer for i in range (1, 11): | This inner loop | loop runs 3 print (i, "x", multiplier, "=", i * multiplier) | prints a single table | iterations, print() | with values 5, 6, 7 Notice that we had to indent the inner loop and the print statement an extra four spaces from the beginning of the outer for loop. This program will print the 5 times, 6 times, and 7 times tables, up to 10 for each table: 12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; ==================== RESTART ===================&gt;&gt;&gt; 1 x 5 = 52 x 5 = 103 x 5 = 154 x 5 = 205 x 5 = 256 x 5 = 307 x 5 = 358 x 5 = 409 x 5 = 4510 x 5 = 501 x 6 = 62 x 6 = 123 x 6 = 184 x 6 = 245 x 6 = 306 x 6 = 367 x 6 = 428 x 6 = 489 x 6 = 5410 x 6 = 601 x 7 = 72 x 7 = 143 x 7 = 214 x 7 = 285 x 7 = 356 x 7 = 427 x 7 = 498 x 7 = 569 x 7 = 6310 x 7 = 70 Although you might think it’s pretty boring, a good way to see what’s going on with nested loops is to just print some stars to the screen and count them. We’ll do that in the next section. Variable loops Fixed numbers, like the ones we’ve used in the range() function, are also called constants. If you use constants in the range() function of a for loop, the loop will run the same number of times whenever the program is run. In that case, we say the number of loops is hard-coded, because it’s defined in your code and it never changes. That’s not always what we want. Sometimes we want the number of loops to be determined by the user, or by another part of the program. For that, we need a variable. For example, let’s say you were making a space-shooter game. You’d have to keep redrawing the screen as aliens get wiped out. You’d have some sort of counter to keep track of how many aliens were left, and whenever the screen was updated, you’d need to loop through the remaining aliens and draw their images on the screen. The number of aliens would change every time the player wiped out another one. Because we haven’t learned how to draw aliens on the screen yet, here’s a simple example program that uses a variable loop: 123numStars = int(input ("How many stars do you want? "))for i in range(1, numStars): print ('*'), 1234&gt;&gt;&gt; ====================== RESTART ======================&gt;&gt;&gt; How many stars do you want? 5* * * * The program asked the user how many stars he wanted, and then it used a variable loop to print that many. Well, almost! We asked for five stars and only got four! Oops, we forgot that the for loop stops one short of the second number in the range. So we need to add 1 to the user’s input. 123numStars = int(input("How many stars do you want? "))for i in range(1, numStars + 1): print ('*', end='') Here’s how that would look: 1234&gt;&gt;&gt; ====================== RESTART =====================&gt;&gt;&gt; How many stars do you want? 5* * * * * Variable nested loops Now let’s try a variable nested loop. That’s just a nested loop where one or more of the loops uses a variable in the range() function. 123456numLines = int(input('How many lines of stars do you want? '))numStars = int(input('How many stars per line? '))for line in range(0, numLines): for star in range(0, numStars): print ('*', end='') print() Try running this program to see if it makes sense. You should see something like this: 1234567&gt;&gt;&gt; ============================ RESTART ============================&gt;&gt;&gt; How many lines of stars do you want? 3How many stars per line? 5*************** The first two lines ask the user how many lines she wants and how many stars per line. It remembers the answers using the variables numLines and numStars. Then we have the two loops: ■ The inner loop (for star in range (0, numStars):) prints each star, and runs once for each star on a line. ■ The outer loop (for line in range (0, numLines):) runs once for each line of stars. The second print command is needed to start a new line of stars. If we didn’t have that, all the stars would print on one line, because of the comma in the first print statement. We can even have nested-nested loops (or double-nested loops). 123456789numBlocks = int(input('How many blocks of stars do you want? '))numLines = int(input('How many lines in each block? '))numStars = int(input('How many stars per line? '))for block in range(0, numBlocks): for line in range(0, numLines): for star in range(0, numStars): print ('*', end='') print() print() Here’s the output: 12345678910111213141516&gt;&gt;&gt; ======================= RESTART =======================&gt;&gt;&gt; How many blocks of stars do you want? 3How many lines of stars in each block? 4How many stars per line? 8* * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * ** * * * * * * * We say the loop is nested “three deep.” Even more variable nested loops 1234567numBlocks = int(input('How many blocks of stars do you want? '))for block in range(1, numBlocks + 1): for line in range(1, block * 2 ): |Formulas for number for star in range(1, (block + line) * 2): |of lines and stars print ('*', end='') print() print() Here’s the output: 123456789101112&gt;&gt;&gt; ======================= RESTART =======================&gt;&gt;&gt; How many blocks of stars do you want? 3* * ** * * * ** * * * * * ** * * * * * * * ** * * * * * ** * * * * * * * ** * * * * * * * * * ** * * * * * * * * * * * ** * * * * * * * * * * * * * * In above example, the loop variables of the outer loops are used to set the ranges for the inner loops. So instead of each block having the same number of lines and each line having the same number of stars, they’re different each time through the loop. You can nest loops as deep as you want. It can get a bit hairy keeping track of what’s going on, so it sometimes helps to print out the values of the loop variables, as in following 12345678numBlocks = int(input('How many blocks of stars do you want? '))for block in range(1, numBlocks + 1): print ('block = ', block) for line in range(1, block * 2 ): for star in range(1, (block + line) * 2): print ('*', end='') print (' line = ', line, 'star = ', star) print() Here’s the output of the program: 123456789101112131415&gt;&gt;&gt; ======================= RESTART =======================&gt;&gt;&gt; How many blocks of stars do you want? 3block = 1* * * line = 1 star = 3block = 2* * * * * line = 1 star = 5* * * * * * * line = 2 star = 7* * * * * * * * * line = 3 star = 9block = 3* * * * * * * line = 1 star = 7* * * * * * * * * line = 2 star = 9* * * * * * * * * * * line = 3 star = 11* * * * * * * * * * * * * line = 4 star = 13* * * * * * * * * * * * * * * line = 5 star = 15 Printing the values of variables can help you in lots of situations—not just with loops. It’s one of the most common debugging methods. Using nested loops So what can we do with all these nested loops? Well, one of the things they’re good for is figuring out all the possible permutations and combinations of a series of decisions. Permutation is a mathematical term that means a unique way of combining a set of things. Combination means something very similar. The difference is that, with a combination, the order doesn’t matter, but with a permutation, the order does matter. If I asked you to pick three numbers from 1 to 20, you could pick • 5, 8, 14 • 2, 12, 20 and so on. If we tried to make a list of all the permutations of three numbers from 1 to 20, these two would be separate entries: • 5, 8, 14 • 8, 5, 14 That’s because, with permutations, the order in which they appear matters. If we made a list of all the combinations, all these would count as a single entry: • 5, 8, 14 • 8, 5, 14 • 8, 14, 5 That’s because order doesn’t matter for combinations. The best way to explain this is with an example. Let’s imagine you’re running a hot dog stand at your school’s spring fair, and you want to make a poster showing how to order all possible combinations of hot dog, bun, ketchup, mustard, and onions by number. So we need to figure out what all the possible combinations are. One way to think about this problem is to use something called a decision tree. The next figure shows a decision tree for the hot dog problem. Each decision point has only two choices, Yes or No. Each different path down the tree describes a different combination of hot dog parts. The path I highlighted says “Yes” for hot dog, “No” for bun, “Yes” for mustard, and “Yes” for ketchup. Now we’re going to use nested loops to list all the combinations—all the paths through the decision tree. Because there are five decision points, there are five levels in our decision tree, so there will be five nested loops in our program. (Above figure only shows the first four levels of the decision tree.) Type the code like this: See how the loops are all one inside the other? That’s what nested loops really are—loops inside other loops. ■ The outer (dog) loop runs twice. ■ The bun loop runs twice for each iteration of the dog loop. So it runs 2 x 2 = 4 times. ■ The ketchup loop runs twice for each iteration of the dog loop. So it runs 2 x 2 x 2 = 8 times. ■ And so on. The innermost loop (that’s the one farthest in—the onion loop) runs 2 x 2 x 2 x 2 x 2 = 32 times. This covers all the possible combinations. So there are 32 possible combinations. Run the program, you should get something like this: 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; =========================== RESTART ===========================&gt;&gt;&gt; Dog Bun Ketchup Mustard Onions# 1 0 0 0 0 0# 2 0 0 0 0 1# 3 0 0 0 1 0# 4 0 0 0 1 1# 5 0 0 1 0 0# 6 0 0 1 0 1# 7 0 0 1 1 0# 8 0 0 1 1 1# 9 0 1 0 0 0# 10 0 1 0 0 1# 11 0 1 0 1 0# 12 0 1 0 1 1# 13 0 1 1 0 0# 14 0 1 1 0 1# 15 0 1 1 1 0# 16 0 1 1 1 1# 17 1 0 0 0 0# 18 1 0 0 0 1# 19 1 0 0 1 0# 20 1 0 0 1 1# 21 1 0 1 0 0# 22 1 0 1 0 1# 23 1 0 1 1 0# 24 1 0 1 1 1# 25 1 1 0 0 0# 26 1 1 0 0 1# 27 1 1 0 1 0# 28 1 1 0 1 1# 29 1 1 1 0 0# 30 1 1 1 0 1# 31 1 1 1 1 0# 32 1 1 1 1 1 The five nested loops run through all possible combinations of dog, bun, ketchup, mustard, and onion. We used the tab character to line everything up. That’s the parts. We haven’t talked about print formatting yet, but if you want to know more about it, you can have a peek at chapter 21. We used a variable called count to number each combination. So, for example, a hot dog with bun and mustard would be #27. Of course, some of the 32 combinations don’t make sense. (A hot dog with no bun but with mustard and ketchup would be a little messy.) But you know what they say: “The customer is always right!” Counting calories Since everyone is concerned about nutrition these days, let’s add a calorie count for each combination on the menu. (You might not care about the calories, but I bet your parents do!) That will let us use some of Python’s math abilities, which we learned before. We already know which items are in each combination. All we need now are the calories for each item. Then we can add them all up in the innermost loop. Here’s some code that sets how many calories are in each item: 12345dog_cal = 140bun_cal = 120mus_cal = 20ket_cal = 80onion_cal = 40 Now we just need to add them up. We know there’s either 0 or 1 of each item in each menu combination. So we can just multiply the quantity by the calories for every item, like this: 123tot_cal = (dog * dog_cal) + (bun * bun_cal) + \ (mustard * mus_cal) + (ketchup * ket_cal) + \ (onion * onion_cal) Because the order of operations is multiplication first, then addition, I didn’treally need to put in the parentheses. I just put them in to make it easier to seewhat’s going on. Long lines of code Did you notice the backslash (\) characters at the end of the lines in the previous code? If youhave a long expression that won’t fit on a single line, you can use the backslash character to tellPython, “This line isn’t done. Treat whatever is on the next line as if it’s part of this line.” Here we used two backslashes to split our long line into three short lines. The backslash is called a linecontinuation character, and several programming languages have them. You can also put an extra set of parentheses around the whole expression, and then you can split your expression over multiple lines without using the backslash, like this: 123tot_cal = ((dog * dog_cal) + (bun * bun_cal) + (mustard * mus_cal) + (ketchup * ket_cal) + (onion * onion_cal)) Putting this all together, the new calorie-counter version of the hot dog program is shown down. 123456789101112131415161718192021dog_cal = 140bun_cal = 120ket_cal = 80 mus_cal = 20onion_cal = 40print("\tDog \tBun \tKetchup\tMustard\tOnions\tCalories")count = 1for dog in [0, 1]: for bun in [0, 1]: for ketchup in [0, 1]: for mustard in [0, 1]: for onion in [0, 1]: total_cal = (bun * bun_cal)+(dog * dog_cal) + \ (ketchup * ket_cal)+(mustard * mus_cal) + \ (onion * onion_cal) print("#", count, "\t",) print(dog, "\t", bun, "\t", ketchup, "\t", end='') print(mustard, "\t", onion, end='') print("\t", total_cal) count = count + 1 The output should look like this: 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt; =========================== RESTART ===========================&gt;&gt;&gt; Dog Bun Ketchup Mustard Onions Calories# 1 0 0 0 0 0 0# 2 0 0 0 0 1 40# 3 0 0 0 1 0 20# 4 0 0 0 1 1 60# 5 0 0 1 0 0 80# 6 0 0 1 0 1 120# 7 0 0 1 1 0 100# 8 0 0 1 1 1 140# 9 0 1 0 0 0 120# 10 0 1 0 0 1 160# 11 0 1 0 1 0 140# 12 0 1 0 1 1 180# 13 0 1 1 0 0 200# 14 0 1 1 0 1 240# 15 0 1 1 1 0 220# 16 0 1 1 1 1 260# 17 1 0 0 0 0 140# 18 1 0 0 0 1 180# 19 1 0 0 1 0 160# 20 1 0 0 1 1 200# 21 1 0 1 0 0 220# 22 1 0 1 0 1 260# 23 1 0 1 1 0 240# 24 1 0 1 1 1 280# 25 1 1 0 0 0 260# 26 1 1 0 0 1 300# 27 1 1 0 1 0 280# 28 1 1 0 1 1 320# 29 1 1 1 0 0 340# 30 1 1 1 0 1 380# 31 1 1 1 1 0 360# 32 1 1 1 1 1 400&gt;&gt;&gt; Just imagine how tedious it would be to work out the calories for all these combinations by hand, even if you had a calculator to do the math. It’s way more fun to write a program to figure it all out for you. Looping and a bit of math in Python make it a snap! What did you learn? In this chapter, you learned about ■ nested loops. ■ variable loops. ■ permutations and combinations. ■ decision trees. Test your knowledge How do you make a variable loop in Python? How do you make a nested loop in Python? What’s the total number of stars that will be printed by the following code: 123for i in range(5): for j in range(3): print('*', end='') What will the output from the code in question #3 look like? If a decision tree has four levels and two choices per level, how many possible choices (paths through the decision tree) are there? Try it out Remember the countdown-timer program we created in chapter 8? Here it is, to refresh your memory: 12345import timefor i in range (10, 0, -1): print i time.sleep(1)print("BLAST OFF!") Modify the program to use a variable loop. The program should ask the user where thecountdown should start, like this: 1234567Countdown timer: How many seconds? 44321BLAST OFF! Take the program you wrote in question #1, and have it print a row of stars beside each number, like this: 1234567Countdown timer: How many seconds? 44 * * * *3 * * *2 * *1 *BLAST OFF! (Hint: You probably need to use a nested loop.)]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 08]]></title>
    <url>%2F2017%2F09%2F21%2Fpython3-learning-08%2F</url>
    <content type="text"><![CDATA[Just for You—Comments Up until now, everything we have typed into our programs (and in interactive mode) has been instructions to the computer. But it’s a very good idea to include some notes to yourself in your programs, describing what the program does and how it works. This will help you (or someone else) look at your program later and figure out what you did. In a computer program, these notes are called comments. Adding comments Comments are only for you to read, not for the computer to execute. Comments are part of the program’s documentation, and the computer ignores them when it runs your program. Python has a couple of ways to add comments to your program. &gt;Documentation is information about a program that describes the program and how it works. Comments are one part of a program’s documentation, but there may be other parts, outside the code itself, that describe things like · why the program was written (its purpose) · who wrote it · who it’s meant for (its audience) · how it’s organized and much more. Larger, more complicated programs usually have more documentation. Single-line comments You can make any line into a comment by starting it with the “#” character. (This is called the number sign or sometimes the pound sign.) 12# This is a comment in a Python programprint('This is not a comment') If you run these two lines, you’ll get the following output: This is not a comment The first line is ignored when the program runs. The comment, which starts with the # character, is only for you and other people reading the code. End-of-line comments You can also put comments at the end of a line of code, like this: 12# This is a comment in a Python programarea = length * width # Calculate the area of the rectangle The comment starts at the # character. Everything before the # is a normal line of code. Everything after that is a comment. Multiline comments Sometimes you want to use more than one line for comments. You could use several lines with the # character at the start of each, like this: 12345# ***************# This is a program to illustrate how comments are used in Python# The row of stars is used to visually separate the comments# from the rest of the code# *************** Multiline comments are good for making sections of your code stand out visually when you’re reading it. You can use them to describe what’s going on in a section of code. A multiline comment at the start of a program could list the author’s name, the name of the program, the date it was written or updated, and any other information you think might be useful. Triple-quoted strings There is another way to make something that acts like a multiline comment in Python. You can just make a triple-quoted string with no name. So you can do this: 12345""" Here is a comment that is on multiplelines, using a triple-quoted string.It's not really a comment, but itbehaves like one.""" Because the string has no name and the program isn’t “doing” anything with the string, it has no effect on the way the program runs. So it acts like a comment, even though it isn’t a comment in strict Python terms. Some Python programmers say that you shouldn’t use triple-quoted strings (multiline strings) as comments. Personally, I don’t see any good reason not to. The reason for comments is to make your code more readable and understandable. If you find that triple-quoted strings are convenient for you, it’s more likely you’ll put comments in your code, which is a good thing. Commenting style So now you know how to add comments. But what kind of stuff should you put in them? Because they don’t affect how the program runs, we say that they’re a matter of “style.” That means you can put anything you want in your comments (or not use any at all). But it doesn’t mean comments are not important. Most programmers learn this the hard way, when they go back to a program they wrote several weeks, months, or years ago (or even one they wrote yesterday) and can’t understand it! That’s usually because they didn’t put in enough comments to explain how the program worked. It might seem obvious when you’re writing it, but it can be a complete mystery when you look at it later. There are no hard-and-fast rules for what you should put in comments, but I encourage you to add as many comments as you like. For now, the more the better. It’s better to err on the side of too many comments than too few. As you get more experience with programming, you’ll get a feel for how much and what kind of commenting works best for you. Commenting out You can also use comments to temporarily exclude parts of the program from running. Anything that is a comment will be ignored. 123456#print "Hello"print("World")&gt;&gt;&gt; =============== RESTART ================&gt;&gt;&gt; World&gt;&gt;&gt; Because print(&quot;Hello&quot;) was commented out, that line was not executed, so the word “Hello” didn’t print. This is useful when you’re debugging a program and only want certain parts to run and other parts to be ignored. Just put a # in front of any line you want the computer to ignore, or put triple quotes around a section of code you want the computer to ignore. What did you learn? In this chapter, you learned that ■ comments are just for you (and other humans), not for the computer. ■ comments can also be used to block out parts of the code, to prevent them from running. ■ you can use triple-quoted strings as a kind of comment that spans multiple lines. Test your knowledge Since comments are pretty simple, we’ll take a break and not have any test questions for this chapter.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 07]]></title>
    <url>%2F2017%2F09%2F20%2Fpython3-learning-07%2F</url>
    <content type="text"><![CDATA[Loop the Loop For most people, doing the same thing over and over again is very boring, so why not let the computer do that for us? Computers never get bored, so they’re great at doing repetitive tasks. In this chapter, we’re going to see how to make the computer repeat things. Computer programs often repeat the same steps over and over again. This is called looping. There are two main kinds of loops: ■ those that repeat a certain number of times—these are called counting loops ■ those that repeat until a certain thing happens—these are called conditional loops because they keep going as long as some condition is true Counting loops The first kind of loop is called a counting loop. You’ll also hear it called a for loop, because many languages, including Python, use the for keyword to create this kind of loop in a program. Let’s try a program that uses a counting loop. 12for looper in [1, 2, 3, 4, 5]: print("hello") You should see something like this: 12345678&gt;&gt;&gt; ================ RESTART ================&gt;&gt;&gt; hellohellohellohellohello&gt;&gt;&gt; Hey, is there an echo in here? The program printed “hello” five times, even though there was only one print statement. How? The first line (for looper in [1, 2, 3, 4, 5]:) translated into plain English means this: looper will start with the value 1 (so looper = 1). The loop will do whatever is in the next block of instructions one time for each value in the list. (The list is those numbers in square brackets.) Each time through the loop, the variable looper is assigned the next value in the list. The second line (print (&quot;hello&quot;)) is the block of code that Python will executeeach time around the loop. A for loop needs a block of code to tell the program what to do in each loop. That block (the indented part of the code) is called the body of the loop. (Remember, we talked about indenting and blocks in the last chapter.) &gt;Each time through the loop is called an iteration. Let’s try something else. Instead of printing the same thing every time, let’s make it print something different every time through the loop. 12for looper in [1, 2, 3, 4, 5]: print (looper) The results should look like this: 12345678&gt;&gt;&gt; ================ RESTART ================&gt;&gt;&gt; 12345&gt;&gt;&gt; This time, instead of printing “hello” five times, it printed the value of the variable looper. Each time through the loop, looper takes the next value in the list. What are the square brackets for? You might have noticed that our list of loop values is enclosed in square brackets. The square brackets and the commas between the numbers are the way you make a list in Python. We’ll learn more about lists soon. But for now, just know that a list is a kind of “container” for storing a bunch of things together. In this case, the things are numbers—the values that looper takes as it goes through different iterations of the loop. Using a counting loop Now let’s do something a bit more useful with loops. Let’s print a multiplication table. It only takes a small change to our program. 12for looper in [1, 2, 3, 4, 5]: print(looper, "times 8 =", looper * 8) You should see something like this: Now we’re starting to see the power of loops. Without loops, we’d have had to write a program like this one to get the same result: 12345print("1 times 8 =", 1 * 8)print("2 times 8 =", 2 * 8)print("3 times 8 =", 3 * 8)print("4 times 8 =", 4 * 8)print("5 times 8 =", 5 * 8) To make a longer multiplication table (say, up to 10 or 20), this program would be a lot longer, but our loop program would be almost the same (just with more numbers in the list). Loops make this much easier! A shortcut—range() In the previous example, we only looped 5 times: 1for looper in [1, 2, 3, 4, 5]: But what if we wanted the loop to run 100 times, or 1000 times? That would be a lot of typing! Luckily, there’s a shortcut. The range() function lets you just enter the starting and ending values, and it creates all the values in between for you. range() creates a list containing a range of numbers. Let’s use the range() function in our multiplication table example. You should see something like this: 123456&gt;&gt;&gt; ================= RESTART =================&gt;&gt;&gt; 1 times 8 = 82 times 8 = 163 times 8 = 244 times 8 = 32 It’s almost the same as the first one . . . except that it missed the last loop! Why? The answer is that range(1, 5) gives us the list[1, 2, 3, 4]. You can try this in interactive mode: 12&gt;&gt;&gt; print(range(1, 5))[1, 2, 3, 4] Why not 5? Well, that’s just the way the range() function works. It gives you a list of numbers starting at the first number and ending just before the last number. You need to take that into account and adjust the range to get the number of loops you want. Following shows our program modified to give us the 8 times table up to 10. 12for looper in range(1, 11): print(looper, "times 8 =", looper * 8) And here’s what we get when we run it: 123456789101112&gt;&gt;&gt; ================== RESTART ==================&gt;&gt;&gt; 1 times 8 = 82 times 8 = 163 times 8 = 244 times 8 = 325 times 8 = 406 times 8 = 487 times 8 = 568 times 8 = 649 times 8 = 7210 times 8 = 80 In the above program, range(1, 11) gave us a list of numbers from 1 to 10, and the loop did one iteration for each number in the list. Each time through the loop, the variable looper took the next value in the list. By the way, we called our loop variable looper, but you can call it anything you want. A matter of style—loop variable names A loop variable is no different from any other variable. There’s nothing special about it—it’s just a name for a value. It doesn’t matter that we’re using the variable as a loop counter. We said before that you should use variable names that describe what the variables do. That’s why I picked the name looper for the previous example. But loop variables are one place where you can sometimes make an exception. That’s because there’s a convention (remember, that means a common practice) in programming to use the letters i, j, k, and so on, for loop variables. Why i, j, and k for loops? That’s because the early programmers were using programs to ﬁgure out math stuff, and math already uses a, b, c, and x, y, z for other things. Also, in one popular programming language, the variables i, j, and k were always integers—you couldn’t make them any other type. Since loop counters are always integers, they usually picked i, j, and k for their loop counters, and it became common practice. Because lots of people use i, j, and k for loop variables, programmers get used to seeing this in programs. It’s perfectly fine to use other names for loop variables, like we did. But you shouldn’t use i, j, and k for anything other than loop variables. If we used this convention, our program would look like this: 12for i in range (1, 5): print(i, "times 8 =", i * 8) And it would work exactly the same. (Try it and see!) Which names you use for your loop variables is a matter of style. Style is about how your programs look, not about whether they work or not. But if you use the same style as other programmers, your programs will be easier to read, understand, and debug. You’ll also be more used to this style, and it’ll be easier for you to read other people’s programs. A range() shortcut You don’t always have to give range() two numbers like we did in above. You can give it just one number: 12for i in range (1, 5): print(i, "times 8 =", i * 8) This is the same as writing 1for i in range (0, 5): which gives you this list of numbers: [0, 1, 2, 3, 4]. In fact, most programmers start their loops at 0 instead of 1. If you use range(5), you’ll get 5 iterations of the loop, which is easy to remember. You just have to know that the first time through, i will be equal to 0, not 1, and the last time through, it’ll equal 4, not 5. So why do most programmers start loops from 0 instead of 1? Well, back in the good old days, some people started from 1 and some people started from 0. They had these really geeky arguments about which one was better. In the end, the 0 people won. So there you have it. Most people start at 0 today, but you can use whichever you like. Just remember to adjust the upper limit so you get the right number of iterations. Just for fun, I tried doing a loop with a string like this: 12&gt;&gt;&gt; for letter in "Hi there":print(letter) A string is like a list of characters. We learned that counting loops use lists for their iterations. That means you can loop through a string. Each character in the string is one iteration through the loop. So if we print the loop variable, which Carter called letter in his example, we’re printing the letters in the string, one at a time. Because each print statement starts a new line, each of the letters prints on its own line. Counting by steps So far, our counting loops have been counting up by 1 each iteration. What if we want the loop to count in steps of 2? Or 5, or 10? What about counting backwards? The range() function can have an extra argument that allows you to change the size of the steps from the default of 1 to a different size. Arguments are the values that you put inside the parentheses when you use a function like range(). We say that you pass the argument to the function. The term parameter is also used, as in, “pass the parameter”. We’ll learn more about functions, arguments, and parameters soon. We’re going to try some loops in interactive mode. When you type in the first line, with the colon at the end, IDLE will automatically indent the next line for you, because it knows that a for loop needs a block of code following it. When you complete the block of code, press the Enter (or Return) key twice. Try it: 1234567&gt;&gt;&gt; for i in range(1, 10, 2): print(i)13579 We added a third parameter, 2, to the range() function. Now the loop is counting in steps of 2. Let’s try another one: 12345678&gt;&gt;&gt; for i in range (5, 26, 5): print(i) 510152025 Now we’re stepping by 5. How about counting backwards? 123456789101112&gt;&gt;&gt; for i in range(10, 1, -1): print(i) 1098765432 When the third parameter in the range() function is negative, the loop counts down instead of up. Remember that the loop starts at the first number and goes up to (or down to) but not including the second number, so in our last example we only got down to 2, not 1. We can use this to make a countdown timer program. We only need to add a couple more lines. try running it. 12345import timefor i in range (10, 0, -1): print(i) time.sleep(1) print("BLAST OFF!") Don’t worry about the stuff in the program that I haven’t told you about yet, like import, time, and sleep. We’re going to find out all about that in the following chapters. Just try it and see how it works. The important thing here’s the range(10, 0, -1) part, which makes a loop that counts backwards from 10 to 1. Counting without numbers In all the previous examples, the loop variable has been a number. In programming terms, we say that the loop iterates over a list of numbers. But the list doesn’t have to be a list of numbers. As we already saw from Carter’s experiment, it can also be a list of characters (a string). It can also be a list of strings, or anything else. The best way to see how this works is with an example. 12for cool_guy in ["Spongebob", "Spiderman", "Justin Timberlake", "My Dad"]: print(cool_guy, "is the coolest guy ever!") Now we’re not looping over a list of numbers, we’re looping over a list of strings. And instead of i for the loop variable, I used cool_guy. The loop variable cool_guy takes a different value in the list each time through. This is still a kind of counting loop, because even though the list isn’t a list of numbers, Python counts how many items are in the list to know how many times to loop. (I won’t show what the output looks like this time—you’ll see it when you run the program.) But what if we don’t know ahead of time how many iterations we’ll need? What if there’s no list of values we can use? Don’t touch that dial, because that’s coming up next! While we’re on the subject . . . We just learned about the first kind of loop, a for loop or counting loop. The second kind of loop is called a while loop or conditional loop. The for loop is great if you know ahead of time how many times you want the loop to run. But sometimes you want a loop to run until something happens, and you don’t know how many iterations it’ll be until that thing happens. While loops let you do that. In the last chapter, we learned about conditions and testing and the if statement. Instead of counting how many times to run a loop, while loops use a test to decide when to stop a loop. While loops are also called conditional loops. A conditional loop keeps looping while some condition is met. Basically, a while loop keeps asking “Am I done yet? . . . Am I done yet? . . . Am I done yet? . . .” until it’s done. It’s done when the condition is no longer true. While loops use the Python keyword while. Following shows an example. Type the program in, try it, and see how it works. 1234567print"Type 3 to continue, anything else to quit."someInput = raw_input()while someInput == '3': print("Thank you for the 3. Very kind of you.") print("Type 3 to continue, anything else to quit.") someInput = raw_input()print("That's not 3, so I'm quitting now.") This program keeps asking for input from the user. While the input is equal to 3, the condi-tion is true, and the loop keeps running. That’s why this kind of conditional loop is also called a while loop, and it uses the Python while keyword. When the input is not equal to 3, the condition is false, and the loop stops. Bailing out of a loop—break and continue There are times when you want to get out of a loop in the middle, before a for loop is finished counting, or before a while loop has found its end condition. There are two ways to do this: you can jump ahead to the next iteration of the loop with continue, or you can stop looping altogether with break. Let’s look at these more closely. Jumping ahead—continue If you want to stop executing the current iteration of the loop and skip ahead to the next iteration, the continue statement is what you need. The best way to show this is with an example. 1234567for i in range (1, 6): print() print('i =', i,) print('Hello, how',) if i == 3: continue print('are you today?') If we run this program, the output looks like this: 1234567&gt;&gt;&gt; ================== RESTART ==================&gt;&gt;&gt; i = 1 Hello how are you today?i = 2 Hello how are you today?i = 3 Hello howi = 4 Hello how are you today?i = 5 Hello how are you today? Notice that, the third time through the loop (when i == 3), the body of the loop didn’t finish—it jumped ahead to the next iteration (i == 4). That was the continue statement at work. It works the same way in while loops. Bailing out—break What if we want to jump out of the loop completely—never finish counting, or give up waiting for the end condition? The break statement does that. Let’s change only line 6 of listing 8.9, replacing continue with break, and rerun the program to see what happens. 12345&gt;&gt;&gt; ================== RESTART ==================&gt;&gt;&gt; i = 1 Hello how are you today?i = 2 Hello how are you today?i = 3 Hello how This time, the loop didn’t just skip the rest of iteration 3; it stopped altogether. That’s what break does. It works the same way in while loops. I should tell you that some people think using break and continue is a bad idea. Personally, I don’t think they’re bad, but I rarely use them. I thought I’d tell you about break and continue just in case you ever need them. What did you learn? In this chapter, you learned about ■ for loops (also called counting loops). ■ the range() function—a shortcut for counting loops. ■ different step sizes for range(). ■ while loops (also called conditional loops). ■ skipping to the next iteration with continue. ■ jumping out of a loop with break. Test your knowledge How many times would the following loop run? 12for i in range (1, 6): print('Hi, Warren') How many times would the following loop run? And what would the values of i be for each loop? 12for i in range (1, 6, 2): print('Hi, Warren') What list of numbers would range(1, 8) give you? What list of numbers would range(8) give you? What list of numbers would range(2, 9, 2) give you? What list of numbers would range(10, 0, -2) give you? What keyword do you use to stop the current iteration of a loop and jump ahead to the next iteration? When does a while loop end? Try it out Write a program to print a multiplication table (a times table). At the start, it should ask the user which table to print. The output should look something like this: Which multiplication table would you like? 5 Here’s your table: 5 x 1 = 5 5 x 2 = 10 5 x 3 = 15 5 x 4 = 20 5 x 5 = 25 5 x 6 = 30 5 x 7 = 35 5 x 8 = 40 5 x 9 = 45 5 x 10 = 50 You probably used a for loop in your program for question #1. That’s how most people would do it. But just for practice, try doing the same thing with a while loop. Or if you used a while loop in question #1, try it with a for loop. Add something else to the multiplication table program. After asking which table the user wants, ask her how high the table should go. The output should look like this: Which multiplication table would you like? 7 How high do you want to go? 12 Here’s your table: 7 x 1 = 7 7 x 2 = 14 7 x 3 = 21 7 x 4 = 28 7 x 5 = 35 7 x 6 = 42 7 x 7 = 49 7 x 8 = 56 7 x 9 = 63 7 x 10 = 70 7 x 11 = 77 7 x 12 = 84 You can do this with the for loop version of the program, the while loop version, or both.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 06]]></title>
    <url>%2F2017%2F09%2F20%2Fpython3-learning-06%2F</url>
    <content type="text"><![CDATA[Decisions If a program did the same thing every time, it would be a little boring and not very useful. Programs need to be able to make decisions on what to do. We’re going to add some different decision-making techniques to our processing repertoire. Testing Programs need to be able to do different things based on their input. Here are a few examples: ■ If Tim got the right answer, add 1 point to his score. ■ If Jane hit the alien, make an explosion sound. ■ If the file isn’t there, display an error message. To make decisions, programs check (do a test) to see if a certain condition is true or not. In the first example above, the condition is “got the right answer.” Python has only a few ways to test something, and there are only two possible answers for each test: true or false. Here are some questions Python can ask to test something: ■ Are two things equal? ■ Is one thing less than another? ■ Is one thing greater than another? But wait a minute, “got the right answer” isn’t one of the tests we can do, at least not directly. That means we need to describe the test in a way Python can understand. Doing tests and making decisions based on the results is called branching. The program decides which way to go, or which branch to follow, based on the result of the test. Python uses the keyword if to test conditions, like this: 1234if timsAnswer == correctAnswer: print "You got it right!" #These lines form a “block” of code because they’re score = score + 1 #indented from the lines above and belowprint "Thanks for playing." A block of code is one or more lines of code that are grouped together. They’re all related to a particular part of the program (like an if statement). In Python, blocks of code are formed by indenting the lines of code in the block. The colon at the end of the if line tells Python that a block of instructions is coming next. The block includes every line that is indented from the if line, up until the next line that is not indented. &gt;Indenting means that a line of code is pushed over to the right a bit. Instead of starting at the far left, it has some spaces at the beginning, so it starts a few characters away from the left side. If the condition is true, everything in the following block will be done. In the previous short example, the second and third lines make up the block of statements for the if in the first line. Indenting In some languages, indenting is just a matter of style—you can indent however you like (or not at all). But in Python, indenting is a necessary part of how you write the code. Indenting tells Python where blocks of code start and where they end. Some statements in Python, like the if statement, need a block of code to tell them what to do. In the case of the if statement, the block tells Python what to do if the condition is true. It doesn’t matter how far you indent the block, as long as the whole block is indented the same amount. A convention in Python is to use four spaces to indent blocks of code. It would be a good idea to follow this style in your programs. &gt;A convention just means lots of people do it that way. Am I seeing double? Are there actually two equal signs in that if statement (if timsAnswer == correctAnswer)? Yes, there are, and here’s why. People say, “Five plus four is equal to nine,” and they ask, “Is five plus four equal to nine?” One is a statement; the other is a question. In Python we have the same kinds of things—statements and questions. A statement might assign a value to a variable. A question might check if a variable is equal to a certain value. One means you’re setting something (assigning it or making it equal). The other means you’re checking or testing something (is it equal, yes or no?). So Python uses two different symbols. We already saw the equal sign (=) used for setting or assigning values to variables. Here are a few more examples: 123correctAnswer = 5 + 3temperature = 35name = "Bill" For testing whether two things are equal, Python uses a double equal sign (==), like this: 123if myAnswer == correctAnswer:if temperature == 40:if name == "Fred": Testing or checking is also called comparing. The double equal sign is called a comparison operator. Remember, we talked about operators before. An operator is a special symbol that operates on the values around it. In this case, the operation is to test whether the values are equal. Other kinds of tests Lucky for us, the other comparison operators are easier to remember: less than (&lt;), greater than (&gt;), and not equal to (!=). (You can also use &lt;&gt; for not equal to, but most people use !=.) You can also combine &gt; or &lt; with = to make greater than or equal to (&gt;=) and less than or equal to (&lt;=). You might have seen some of these in math class. You can also “chain” two greater-than and less-than operators together to make an in-between test, like this: 1if 8 &lt; age &lt; 12: This will check if the variable age has a value between, but not including, 8 and 12. This would be true if age was equal to 9, 10, or 11 (or 8.1 or 11.6, and so on). If we wanted to include the ages 8 and 12, we’d do this instead: 1if 8 &lt;= age &lt;= 12: Comparison operators are also called relational operators (because they test the relation between the two sides: equal or not equal, greater than or less than). A comparison is also called a conditional test or logical test. In programming, logical refers to something where the answer is either true or false. What happens if the test is false? We’ve seen how to make Python do something if the result of a test is true. But what does it do if the test is false? In Python, there are three possibilities: ■ Do another test. If the first test comes out false, you can get Python to test something else with the keyword elif, (which is short for “else if”) like this: 123456if answer &gt;= 10: print ("You got at least 10!")elif answer &gt;= 5: print ("You got at least 5!")elif answer &gt;= 3: print ("You got at least 3!") You can have as many elif statements as you want after the if. ■ Do something else if all the other tests come out false. You do this with the else keyword. This always goes at the end, after you’ve done the if and any elif statements: 12345678if answer &gt;= 10: print ("You got at least 10!")elif answer &gt;= 5: print ("You got at least 5!")elif answer &gt;= 3: print ("You got at least 3!")else: print ("You got less than 3.") ■ Move on. If you don’t put anything else after the if block, the program will continue on to the next line of code (if there is one) or it’ll end (if there is no more code). Try making a program with the code above by adding a line at the beginning to input a number: 1answer = float(raw_input ("Enter a number from 1 to 15")) Testing for more than one condition What if we want to test for more than one thing? Let’s say you made a game that was for eight-year-olds and up, and you want to make sure the player is in at least third grade. There are two conditions to meet. Here is one way you could test for both conditions: 1234567age = float(raw_input("Enter your age: "))grade = int(raw_input("Enter your grade: "))if age &gt;= 8: if grade &gt;= 3: print ("You can play this game.")else: print ("Sorry, you can’t play the game.") Notice that the first print line is indented eight spaces, not just four spaces. That’s because each if needs its own block, so each one has its own indenting. Using “and” That last example will work fine. But there is a shorter way to do the same thing. You can combine conditions like this: 123456age = float(input("Enter your age: "))grade = int(input("Enter your grade: "))if age &gt;= 8 and grade &gt;= 3: print "You can play this game."else: print "Sorry, you can’t play the game." We combined the two conditions using the and keyword. The and means that both of the conditions have to be true for the following block to execute. You can put more than two conditions together with and: 1234567age = float(input("Enter your age: "))grade = int(input("Enter your grade: "))color = input("Enter your favorite color: ")if age &gt;= 8 and grade &gt;= 3 and color == "green": print ("You are allowed to play this game.")else: print ("Sorry, you can’t play the game.") If there are more than two conditions, all the conditions have to be true for the if statement to be true. There are other ways of combining conditions too. Using “or” The or keyword is also used to put conditions together. If you use or, the block is executed if any of the conditions are true. 12345color = input("Enter your favorite color: ")if color == "red" or color == "blue" or color == "green": print ("You are allowed to play this game.")else: print ("Sorry, you can’t play the game.") Using “not” You can also flip around a comparison to mean the opposite, using not. 12345age = float(input("Enter your age: "))if not (age &lt; 8): print ("You are allowed to play this game.")else: print ("Sorry, you can’t play the game.") This line 1if not (age &lt; 8): means the same as this one: 1if age &gt;= 8: In both cases, the block executes if the age is 8 or higher, and it doesn’t if the age is lower than 8. we saw math operators like +, -, *, and / before. In this chapter, we saw the comparison operators &lt;, &gt;, ==, and so on. The and, or, and not keywords are also operators. They’re called logical operators. They’re used to modify comparisons by combining two or more of them (and, or) or reversing them (not). Following table lists all the operators we’ve talked about so far. Operator Name What it does = Assignment Assigns a value to a name (variable). + Addition Adds two numbers together. This can also be used to concatenate strings. - Subtraction Subtracts two numbers. += Increment Adds one to a number. -= Decrement Subtracts one from a number. * Multiplication Multiplies two numbers together. / Division Divides two numbers. If both numbers are integers, the result will be just the integer quotient, with no remainder. % Modulus Gets the remainder (or modulus) for integer division of two numbers. ** Exponentiation Raises a number to a power. Both the number and the power can be integers or floats. == Equality Checks whether two things are equal. &lt; Less than Checks whether the first number is less than the second number. &gt; Greater than Checks whether the first number is greater than the second num-ber. &lt;= Less than or equal to Checks whether the first number is less than or equal to the second number. &gt;= Greater than or equal to Checks whether the first number is greater than or equal to the second number. != &lt;&gt; Not equal to Checks whether two things are not equal. (Either operator can be used.) What did you learn? In this chapter, you learned about ■ comparison tests and the relational operators. ■ indenting and blocks of code. ■ combining tests using and and or. ■ reversing a test using not. Test your knowledge What will the output be when this program is run: 12345my_number = 7if my_number &lt; 20: print ('Under 20')else: print ('20 or over') From the program in the first question, what will the output be if you change my_number to 25? What kind of if statement would you use to check if a number was greater than 30 but less than or equal to 40? What kind of if statement would you use to check if the user entered the letter “Q” in either uppercase or lowercase? Try it out A store is having a sale. They’re giving 10 percent off purchases of $10 or lower, and 20 percent off purchases of greater than $10. Write a program that asks the purchase price and displays the discount (10% or 20%) and the final price. A soccer team is looking for girls from ages 10 to 12 to play on their team. Write a program to ask the user’s age and if male or female (using “m” or “f”). Display a message indicating whether the person is eligible to play on the team.Bonus: Make the program so that it doesn’t ask for the age unless the user is a girl. You’re on a long car trip and arrive at a gas station. It’s 200 km to the next station. Write a program to figure out if you need to buy gas here, or if you can wait for the next station. The program should ask these questions: ■ How big is your tank, in liters? ■ How full is your tank (in percent—for example, half full = 50)? ■ How many km per liter does your car get? The output should look something like this: Size of tank: 60 percent full: 40 km per liter: 10 You can go another 240 km The next gas station is 200 km away You can wait for the next station. or: Size of tank: 60 percent full: 30 km per liter: 8 You can go another 144 km The next gas station is 200 km away Get gas now! Bonus: Include a 5 liter buffer in your program, in case the fuel gauge isn’t accurate. 4. Make a program where the user has to enter a secret password to use the program. You’ll know the password, of course (because it’ll be in your code). But your friends will either have to ask you, guess the password, or learn enough Python to look at the code and figure it out! The program can be anything you want, including one you have already written, or just a simple one that displays a message like “You’re in!” when he enters the right password.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MWOL Pronunciation Guide]]></title>
    <url>%2F2017%2F09%2F20%2FMWOL-Pronunciation-Guide%2F</url>
    <content type="text"><![CDATA[Pronunciation Guide Pronunciation is not an intrinsic component of the dictionary. For some languages, such as Spanish, Swahili, and Finnish, the correspondence between orthography and pronunciation is so close that a dictionary need only spell a word correctly to indicate its pronunciation. Modern English, however, displays no such consistency in sound and spelling, and so a dictionary of English must devote considerable attention to the pronunciation of the language. The English lexicon contains numerous eye rhymes such as love, move, and rove, words which do not sound alike despite their similar spellings. On the other hand, it also contains rhyming words such as breeze, cheese, ease, frieze, and sleaze whose rhymes are all spelled differently. This grand mismatch between words that look alike and words that sound alike does at least serve to record something of the history of the English-speaking peoples and their language. Spelling often indicates whether a word comes down from the native Anglo-Saxon word stock or was adopted in successive ages from the speech of a missionary monk chanting Latin, a seafaring Viking dickering in Old Norse, a Norman nobleman giving orders in French, or a young immigrant to turn-of-the-century America. For example, the sound is spelled as sh in native English shore, as ch in the French loan champagne, as sk in one pronunciation of the Norwegian loan ski, as si in the Renaissance Latin loan emulsion, and as sch in the recent Yiddish loan schlep. English vowels present different complexities of sound and spelling, due in large part to the fact that William Caxton introduced printing to England in A.D. 1476, many decades before the sound change known as the Great Vowel Shift had run its course. With the rise of printing came an increasingly fixed set of spelling conventions, but the conventionalized spellings soon lost their connection to pronunciation as the vowel shift continued. The stressed vowels of sane and sanity are therefore identical in spelling though now quite different in quality. For the trained observer the vagaries of English orthography contain a wealth of linguistic history; for most others, however, this disparity between sound and spelling is just a continual nuisance at school or work. Readers often turn to the dictionary wanting to learn the exact pronunciation of a word, only to discover that the word may have several pronunciations, as is the case for deity, economic, envelope, and greasy, among many others. The inclusion of variant pronunciations disappoints those who want their dictionary to list one »correct… pronunciation. In truth, though, there can be no objective standard for correct pronunciation other than the usage of thoughtful and, in particular, educated speakers of English. Among such speakers one hears much variation in pronunciation. Dictionaries of English before the modern era usually ignored pronunciation variants, instead indicating a single pronunciation by marking the entry word with diacritics to indicate stress and letter values. These systems were cumbersome, however, and reflected the dialectal biases of the editors more than the facts about how a word was actually spoken. Lexicographers came eventually to recognize the need for separate respellings which could record the entire range of accepted variants along with appropriate notes about dialectal distribution or usage. This dictionary records many types of variation in pronunciation. Distinctions between British and American speech are frequently noted, as are differences among the three major dialect areas of the U.S.Northern, Southern, and Midland. Words that have distinctive pronunciations in Canada, such as decal and khaki, have those pronunciations duly noted. Pronunciations peculiar to certain spheres of activity are also represented, as for example the variants of athwart and tackle heard in nautical use. Finally, a wide range of unpredictable variations are included, such as the pronunication of economic with either or. Unpredictable variations frequently cut across the boundaries of geographical dialects, sometimes running along the lines of social class, ethnicity, or gender instead. In fine, this dictionary attempts to includeeither explicitly or by implicationall pronunciation variants of a word that are used by educated speakers of the English language. The pronunciations in this dictionary are informed chiefly by the Merriam-Webster pronunciation file. This file contains citations that are transcriptions of words used by native speakers of English in the course of utterances heard in speeches, interviews, and conversations. In this extensive collection of 3 × 5 slips of paper, one finds the pronunciations of a host of people: politicians, professors, curators, artists, musicians, doctors, engineers, preachers, activists, journalists, and many others. The Merriam“ Webster pronunciation editors have been collecting these citations from live speech and from radio, television, and shortwave broadcasts since the 1930s. It is primarily on the basis of this large and growing file that questions of usage and acceptability in pronunciation are answered. All of the pronunciations recorded in this book can be documented as falling within the range of generally acceptable variation, unless they are accompanied by a restricting usage note or symbol or a regional label. No system of indicating pronunciation is self explanatory. The following discussion sets out the signification and use of the pronunciation symbols in this book, with special attention to those areas where experience has shown that dictionary users may have questions. More detailed information can be found in the Guide to Pronunciation in Websters Third New International Dictionary. The order of symbols discussed below is the same as the order on the page of Pronunciation Symbols, with the exception that the symbols which are not letter characters are here listed first. Those characters which have corresponding symbols in the International Phonetic Alphabet (IPA) are shown with their IPA equivalents. MWOL Pronunciation Guide.PDF]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 05]]></title>
    <url>%2F2017%2F09%2F19%2Fpython3-learning-05%2F</url>
    <content type="text"><![CDATA[Input What if you want to have the user enter any temperature she wants when the program runs? We said before that a program has three components: input, processing, and output. Our first program had only output. The temperature-conversion program had some processing (converting the temperature) and some output, but no input. It’s time to add the third ingredient to our programs: input. Input means getting something, some kind of information, into a program while it is running. That way we can write programs that interact with the user, which will make things a lot more interesting. Python3 has a built-in function, called input(), that is used to get input from the user. input() The input() function gets a string from the user. The normal way it gets this is from the keyboard—the user types in the input. input() is another one of Python’s built-in functions, like str(), int(), float(), and type(). We’ll learn a lot more about functions later. But for now, you just need to remember to include the parentheses (round brackets) when you use input(). Here is how you use it: 1someName = input() This will let the user type in a string and assign it the name someName. Now let’s put this into a program. 123print ("Enter your name: ")somebody = input()print ("Hi", somebody, "how are you today?") Save and run this program in IDLE to see how it works. You should see something like this: 123Enter your name:WarrenHi Warren how are you today? I typed in my name, and the program assigned it the name somebody. A shortcut for raw_input() prompts There is a shortcut for printing prompt messages. The input() function can print the message for you, so you don’t have to use a print statement: 1someName = raw_input ("Enter your name: ") It is like the input() function has print built in. We will use that shortcut from now on. Inputting numbers We can use the int() or float() functions to create a number from the string that input() gives us. It would look like this: 12temp_string = input() fahrenheit = float(temp_string) We got the user’s input as a string, using input(). Then we made a number from that, using float(). Once we had the temperature as a float, we gave it the name fahrenheit. But there is a little shortcut. We can do it all in one step, like this: 1fahrenheit = float(raw_input()) This does exactly the same thing. It gets the string from the user and then creates a number from it. It just does it with a bit less code. Using int() with input() If the number you want the user to enter will always be an integer (no decimals), you can convert it with int(), like this: 12response = input("How many students are in your class: ")numberOfStudents = int(response) Input from the Web Usually, you get input for a program from the user. But there are other ways to get input, too. You can get it from a file on your computer’s hard drive or you can get it from the Internet. If you have an Internet connection, you can try the program following code. It opens a file from the book’s web site and shows you the message that is in that file. 1234import urllibfile = urllib.urlopen('http://helloworldbook.com/data/message.txt')message = file.read() print (message) That’s it. With just four lines of code, your computer reaches across the Web to get a file from the book’s web site and display it. If you try this program (assuming you have a working Internet connection), you will see the message. What did you learn? In this chapter, you learned about ■ inputting text with input(). ■ adding a prompt message to input(). ■ inputting numbers using int() and float() with input(). Test your knowledge With this code, 1answer = input() if the user types in 12, what type of data is answer? Is it a string or a number? 2. How do you get input() to print a prompt message? 3. How do you get an integer using input()? How do you get a float (decimal number) using input()? Try it out In interactive mode, make two variables, one for your first name and one for your last name. Then, using a single print statement, print your first and last names together. Write a program that asks for your first name, then asks for your last name, and then prints a message with your first and last names in it. Write a program that asks for the dimensions (in feet) of a rectangular room, and then calculates and displays the total amount of carpet needed to cover the room. Write a program that does the same as in #3, but that also asks for the cost per square yard of carpet. Then have the program display these three things: ■ the total amount of carpet, in square feet. ■ the total amount of carpet, in square yards (1 square yard = 9 square feet). ■ the total cost of the carpet. Write a program that helps the user add up her change. The program should ask ■ “How many quarters?” ■ “How many dimes?” ■ “How many nickels?” ■ “How many pennies?” Then it should give the total value of the change.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 04]]></title>
    <url>%2F2017%2F09%2F19%2Fpython3-learning-04%2F</url>
    <content type="text"><![CDATA[Types of Data We have seen that there are at least three different types of things we can assign to a variable (to keep in the computer’s memory): integers, floating-point numbers, and strings. There are other types of data in Python, which we will learn about later, but for now these three will do. In this chapter, we’re going to learn how you can tell what type something is. We will also see how to make one type from another. Changing types Quite often we need to convert data from one type to another. For instance, when we want to print a number, it needs to be converted to text in order for the text to appear on the screen. Python’s print command can do that for us, but sometimes we need to convert without printing, or to convert from strings to numbers (which print can’t do). This is called type conversion. So how does it work? Python doesn’t actually “convert” things from one type to another. It creates a new thing, of the type you want, from the original thing. Here are some functions that convert data from one type to another: ■ float() will create a new float (decimal number) from a string or integer. ■ int() will create a new integer from a string or float. ■ str() will create a new string from a number (or any other type). The parentheses at the end of float(), int(), and str() are there because they are not Python keywords, they are some of Python’s built-in functions. Changing an int to a float Let’s start with an integer and create a new floating-point number (decimal number) from it, using float(): 123456&gt;&gt;&gt; a = 24&gt;&gt;&gt; b = float(a)&gt;&gt;&gt; a24&gt;&gt;&gt; b24.0 Notice that b got a decimal point and a 0 at the end. That tells us it is a float and not an integer. The variable a stayed the same, because float() doesn’t change the original value—it creates a new one. Changing a float to an int Now let’s try the reverse—start with a decimal number and create an integer, using int(): 123456&gt;&gt;&gt; c = 38.0&gt;&gt;&gt; d = int(c)&gt;&gt;&gt; c38.0&gt;&gt;&gt; d38 We created a new integer, d, which is the whole number part of c. Let’s try another one: 123456&gt;&gt;&gt; e = 54.99&gt;&gt;&gt; f = int(e)&gt;&gt;&gt; print e54.99&gt;&gt;&gt; print f54 Even though 54.99 is very close to 55, you still get 54 for the integer. The int() function always rounds down. It doesn’t give you the nearest integer, it gives you the next lowest integer. The int() function basically chops off the decimal part. Changing a string to a float We can also create a number from a string, like this: 123456&gt;&gt;&gt; a = '76.3'&gt;&gt;&gt; b = float(a)&gt;&gt;&gt; a'76.3'&gt;&gt;&gt; b76.3 Notice that, when we displayed a, the result had quotes around it. That’s Python’s way of telling us that a is a string. When we displayed b, we got the floating-point value with all the decimal places. Getting more information: type() Python has another function, type(), which explicitly tells us the type of a variable. Let’s try it: 123456&gt;&gt;&gt; a = '44.2'&gt;&gt;&gt; b = 44.2&gt;&gt;&gt; type(a)&lt;type 'str'&gt;&gt;&gt;&gt; type(b)&lt;type 'float'&gt; The type() function told us that a is of type 'str', which stands for string, and b is of type 'float'. No more guessing! Type-conversion errors Of course, if you give int() or float() something that is not a number, it won’t work. Try it and see: 12345&gt;&gt;&gt; print float("fred")Traceback (most recent call last): File "&lt;pyshell#1&gt;", line 1, in -toplevel- print float ("fred")ValueError: invalid literal for float(): fred We got an error message. The invalid literal error message means that Python doesn’t know how to create a number from “fred”. Do you? Using type conversions Going back to your Fahrenheit to Celsius temperature-conversion program from the “Try it out” section in chapter 3, remember that you needed to fix the integer-division behavior to get the right answer, by changing the 5 to 5.0 or the 9 to 9.0: 1cel = 5.0 / 9 * (fahr – 32) The float() function gives you another way of doing this: 1cel = float(5) / 9 * (fahr – 32) or: 1cel = 5 / float(9) * (fahr – 32) What did you learn? In this chapter, you learned about ■ converting between types (or, more correctly, creating types from other types): str(), int(), and float(). ■ checking the type of a variable using type(). Test your knowledge When you use int() to convert a decimal number to an integer, does the result get rounded up or down? In your temperature-conversion program, would this have worked? cel = float(5 / 9 * (fahr – 32)) What about this: cel = 5 / 9 * float(fahr – 32) If not, why not? (Extra challenging question) Without using any other functions besides int(), how could you get a number to round off instead of round down? (For example, 13.2 would round down to 13, but 13.7 would round up to 14.) Try it out Use float() to create a number from a string like '12.34'. Make sure the result is really a number! Try using int() to create an integer from a decimal number like 56.78. Did the answer get rounded up or down? Try using int() to create an integer from a string. Make sure the result is really an integer!]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《American Accent Video Training Program》]]></title>
    <url>%2F2017%2F09%2F19%2FAmerican-Accent-Video-Training-Program%2F</url>
    <content type="text"><![CDATA[Table of Contents Session 1 R and W Session 2 Voicing, S and Z Session 3 TH, Voiced T Session 4 F and V, Sh and Voiced SH Session 5 L Session 6 Word Endings Session 7 DG and Ch, H Session 8 Vowel Overview, I and EE Session 9 OW and AE Session 10 OO, UH, EH Session 11 AU, AH, A Session 12 Tongue Twisters Session 13 Phrase Reductions, Intonation Session 14 Reading Passages Session 15 Reading Passages Download links: VIDEO | American Accent Video Training Program - Paul S. Gruber MS]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 03]]></title>
    <url>%2F2017%2F09%2F18%2Fpython3-learning-03%2F</url>
    <content type="text"><![CDATA[Basic Math The four basic operations We already saw Python do a little math in chapter 1: addition, using the plus (+) sign, and multiplication, using the asterisk (*) sign. Python uses the hyphen (-) (which is also called the minus sign) for subtraction, as you would expect: 12&gt;&gt;&gt; print 8 – 53 Because computer keyboards don’t have a division (÷) symbol, all programs use the forward slash (/) for division. 12&gt;&gt;&gt; print 6/23 Integers are the numbers you can easily count, like 1, 2, 3, as well as 0 and the negative numbers, like –1, –2, –3. Decimal numbers (also called real numbers) are the numbers with a decimal point and some digits after it, like 1.25, 0.3752, and –101.2. In computer programming, decimal numbers are also called floating-point numbers, or sometimes floats for short (or float for just one of them). This is because the decimal point “floats” around. You can have the number 0.00123456 or 12345.6 in a float. If you enter either of the two numbers as a decimal number, Python knows you want the answer as a decimal number. 12&gt;&gt;&gt; print 3.0 / 21.5 Operators The +, -, *, and / symbols are called operators. That’s because they “operate on,” or work with, the numbers we put around them. The = sign is also an operator, and it is called the assignment operator, because we use it to assign a value to a variable. Order of operations 12&gt;&gt;&gt; print 2 + 3 * 414 The order that Python uses is the same one you learned (or will learn) in math class. Exponents come first, then multiplication and division, and then addition and subtraction. If you want to change the order of operations and make something go first, you just put parentheses (round brackets) around it, like this: 12&gt;&gt;&gt; print (2 + 3) * 420 Two more operators Exponentiation—raising to a power If you wanted to multiply 3 by itself 5 times, you could write 12&gt;&gt;&gt; print 3 * 3 * 3 * 3 * 3243 But this is the same as 3 5 , or “three exponent five,” or “three to the power of five.” Python uses a double star (asterisk) for exponents or raising a number to a power. 12&gt;&gt;&gt; print 3 ** 5243 One reason for using an exponent instead of just multiplying several times is that it is easier to type. But a more important reason is that with ** you can have exponents that are not integers, like this: 12&gt;&gt;&gt; print 3 ** 5.5420.888346239 There is no easy way to do that using just multiplication. Modulus—getting the remainder Python has a special operator for calculating the remainder for integer division. It is called the modulus operator, and the symbol is the percent symbol (%). You use it like this: 12&gt;&gt;&gt; print 7 % 21 Increment and decrement Remember the example from the last chapter: score = score + 1? We said that was called incrementing. A similar thing is score = score - 1, which is called decrementing. These are done so often in programming that they have their own operators: += (increment) and -= (decrement). 1234&gt;&gt;&gt; number = 7&gt;&gt;&gt; number += 1&gt;&gt;&gt; print (number)8 or: 1234&gt;&gt;&gt; number = 7&gt;&gt;&gt; number -= 1&gt;&gt;&gt; print (number)6 The first one adds one to the number. (It changes from 7 to 8.) The second one subtracts one from the number. (It changes from 7 to 6.) Really big and really small Try this in interactive mode: 123&gt;&gt;&gt; print 9938712345656.34 * 4823459023067.4564.79389717413e+025&gt;&gt;&gt; (It doesn’t matter exactly what numbers you type in—any big numbers with decimals will do.) The e is one way of displaying really big or really small numbers on a computer. It’s called E-notation. When we’re working with really big (or really small) numbers, showing all the digits and decimal places can be kind of a pain. These kinds of numbers show up a lot in math and science. For example, if an astronomy program was displaying the number of kilometers from Earth to the star Alpha Centauri, it could show 38000000000000000 or 38,000,000,000,000,000 or 38 000 000 000 000 000. (That’s 38 quintillion kilometers!) But either way, you would get tired of counting all those zeros. Another way to display this number is to use scientific notation, which uses powers of 10 along with decimal numbers. In scientific notation, the distance to Alpha Centauri would be written like this: 3.8 x 10 16 . (See how the 16 is raised above the line, and is smaller?) This reads as “three point eight times ten to the power of sixteen” or “three point eight times ten to the sixteenth.” What it means is you take 3.8 and move the decimal point sixteen places to the right, adding zeros as needed. Scientific notation is great if you can write the 16 as an exponent, raised above the line and smaller, like we did here. If you are working with pencil and paper, or a program that supports superscripts, then you can use scientific notation. &gt;Superscript means a character or characters that are raised above the rest of the text, like this: 10^13 . The 13 here is the superscript. Usually, superscripts are also smaller than the main text. E-notation In E-notation, our number would be 3.8E16 or 3.8e16. This reads as “three point eight exponent sixteen” or “three point eight e sixteen” for short. It is assumed that the exponent is a power of 10. That’s the same as writing 3.8x10^16 For very small numbers, like 0.0000000000001752, a negative exponent is used. The scien-tific notation would be 1.752x10 -13 , and the E-notation would be 1.752e-13. A negative exponent means to move the decimal place to the left instead of the right. You can use E-notation to enter very big and very small numbers (or any number, for that matter) into Python. Later we will see how to make Python print numbers using E-notation. Try entering some numbers in E-notation: 12345&gt;&gt;&gt; a = 2.5e6&gt;&gt;&gt; b = 1.2e7&gt;&gt;&gt; print (a + b)14500000.0&gt;&gt;&gt; Although we entered the numbers in E-notation, the answer came out as a regular decimal number. That’s because Python won’t display numbers in E-notation unless you specifically tell it to, or the numbers are really big or really small (lots of zeros). Try this: 12345&gt;&gt;&gt; c = 2.6e75&gt;&gt;&gt; d = 1.2e74&gt;&gt;&gt; print c + d2.72e+075&gt;&gt;&gt; This time, Python displayed the answer in E-notation automatically, because it wouldn’t make sense to display a number with 73 zeros! Exponents vs. E-notation Don’t get confused between raising a number to a power (also called exponentiation) and E-notation. 3**5 means 3^5 , or “three to the fifth power” or 3 * 3 * 3 * 3 * 3, which is equal to 243. 3e5 means 3 * 10^5 or “three times ten to the fifth power,” or 3 * 10 * 10 * 10 * 10 *10, which is equal to 300,000. Raising to a power means you are raising the number itself to that power. E-notation means you are multiplying by a power of 10. Some people would read both 3e5 and 3**5 as “three exponent five,” but they are two different things. It doesn’t matter so much how you say it, as long as you understand what each one means. What did you learn? how to do basic math operations in Python. about integers and floats. about exponentiation (raising numbers to a power). how to calculate the modulus (the remainder). all about E-notation. Test your knowledge What symbol does Python use for multiplication? What answer would Python give for 8 / 3? How would you get the remainder for 8 / 3? How would you get the decimal answer for 8 / 3? What’s another way of calculating 6 * 6 * 6 * 6 in Python? How would you write 17,000,000 in E-notation? What would 4.56e-5 look like in regular notation (not E-notation)? Try it out Solve the following problems either using interactive mode or by writing a small program: Three people ate dinner at a restaurant and want to split the bill. The total is $35.27,and they want to leave a 15 percent tip. How much should each person pay? Calculate the area and perimeter of a rectangular room, 12.5 meters by 16.7 meters. Write a program to convert temperatures from Fahrenheit to Celsius. The formula for that is: C = 5 / 9 * (F - 32). (Hint: Watch out for the integer-division gotcha!) Do you know how to figure out how long it will take to get somewhere in a car? The formula (in words) is “travel time equals distance divided by speed.” Make a program to calculate the time it will take to drive 200 km at 80 km per hour and display the answer.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 02]]></title>
    <url>%2F2017%2F09%2F17%2Fpython3-learning-02%2F</url>
    <content type="text"><![CDATA[Names 12&gt;&gt;&gt;Teacher = "Mr. Morton"&gt;&gt;&gt;print (Teacher) You just created a thing that is made up of the letters “Mr. Morton”, and you gave it the name Teacher. The equal sign (=) tells Python to assign or “make equal to.” You assigned the name Teacher to the series of let- ters “Mr. Morton”. When you assign a value to a name (like assigning the value “Mr. Morton” to Teacher), it is stored in memory and is called a variable. In most programming languages, we say you store a value in a variable. But Python does things a little differently from most other computer languages. Instead of storing values in variables, it’s more like putting names on values. Let’s try that one with variables: 1234&gt;&gt;&gt; First = 5&gt;&gt;&gt; Second = 3&gt;&gt;&gt; print (First + Second)8 Here, we created two names, First and Second. The number 5 was assigned to First, and the number 3 was assigned to Second. Then we printed the sum of the two. There’s another way to do this. Try this: 123&gt;&gt;&gt; Third = First + Second&gt;&gt;&gt; Third8 Notice what we did here. In interactive mode, we can display the value of a variable just by typing its name, without using print. (This doesn’t work in a program.) You can have more than one name for the same thing. Try this in interactive mode: 123456&gt;&gt;&gt; a = "Apple"&gt;&gt;&gt; b = a&gt;&gt;&gt; a"Apple"&gt;&gt;&gt; b"Apple" This is like sticking two tags on the same thing. One tag says a and one tag says b, but they are both stuck on “Apple”. What’s in a name? You can call a variable anything you want (well, almost). The name can be as long as you want, and it can have letters and numbers in it, as well as the underscore character (_). But there are a few rules about variable names. The most important one is that they are case-sensitive, which means that uppercase and lowercase matter. So, teacher and TEACHER are two different names. So are first and First. Another rule is that a variable name has to start with a letter or the underscore character. It can’t start with a number. So 4fun is not allowed. One more rule is that a variable name can’t have any spaces in it. Numbers and strings A character, or series of characters (letters, numbers, or punctuation), is called a string. The way you tell Python that you are making a string is to put quotes around the characters. Python is not too fussy about whether you use single or double quotes. Either of these will work: 12&gt;&gt;&gt; teacher = "Mr. Morton"&gt;&gt;&gt; teacher = 'Mr. Morton' Concatenate It’s not really correct to say “added” when talking about strings (like we just did). When you put characters or strings together to make a longer string, there is a special name for it. Instead of “adding” (which is only for numbers), it is called concatenation. This sounds like kon-kat-en-ay-shun. We say that you concatenate two strings. Long strings If you want to have a string that spans more than one line, you have to use a special kind of string called a triple-quoted string. Here is what it looks like: 1234long_string = """Sing a song of sixpence, a pocket full of rye,Four and twenty black birds baked in a pie.When the pie was opened the birds began to sing.Wasn't that a dainty dish to set before the king?""" This kind of string starts and ends with three quote marks. The quote marks can be double or single quotes, so you could also do it this way: 1234long_string = '''Sing a song of sixpence, a pocket full of rye,Four and twenty black birds baked in a pie.When the pie was opened the birds began to sing.Wasn't that a dainty dish to set before the king?''' Triple-quoted strings can be very useful when you have several lines of text that you want to display together, and you don’t want to use a separate string for each line. How “variable” are they? Variables are called “variables” for a reason. It’s because they are . . . well . . . variable! That means you can vary, or change, the value that is assigned to them. In Python, you do this by creating a new thing that is different from the old thing, and sticking the old label (the name) on the new thing. Remember that things can have more than one name (more than one tag stuck on them). The new me You can also make a variable equal to itself: 12&gt;&gt;&gt; Score = 7&gt;&gt;&gt; Score = Score I bet you’re thinking, “Well, that’s pretty useless!” And you’d be right. It’s kind of like saying “I am me.” But with a small change, you can become a whole new you! Try this: 123&gt;&gt;&gt; Score = Score + 1&gt;&gt;&gt; print (Score)8 What happened here? In the first line, the Score tag was stuck on the value 7. We made a new thing, which was Score + 1, or 7 + 1. That new thing is 8. Then we took the Score tag off the old thing (7) and stuck it on the new thing (8). So Score has been reassigned from 7 to 8. Whenever we make a variable equal something, the variable always appears on the left side of the equal sign (=). The trick is that the variable can also appear on the right. This turns out to be quite useful, and you’ll see it in a lot of programs. The most common use is to increment a variable (increase it by a certain amount), like we just did, or the opposite, to decrement a variable (decrease it by a certain amount). What did you learn? In this chapter, you learned how to “remember” or keep things in the computer’s memory using variables. that variables are also called “names” or “variable names.” that variables can be different kinds of things, such as numbers and strings. Test your knowledge How do you tell Python that a variable is a string (characters) instead of a number? Once you have created a variable, can you change the value that is assigned to it? With variable names, is TEACHER the same as TEACHEr? Is ‘Blah’ the same as “Blah” to Python? Is '4' the same as 4 to Python? Which of the following is not a correct variable name? Why? Teacher2 2Teacher teacher_25 TeaCher Is “10” a number or a string? Try it out Make a variable and assign a number to it (any number you like). Then display your variable using print. Modify your variable, either by replacing the old value with a new value, or by adding something to the old value. Display the new value using print. Make another variable and assign a string (some text) to it. Then display it using print. Just like in the last chapter, in interactive mode, get Python to calculate the number of minutes in a week. But this time, use variables. Make a variable for DaysPerWeek, HoursPerDay, and MinutesPerHour (or make up your own names), and then multiply them together. People are always saying there’s not enough time to get everything done. How many minutes would there be in a week if there were 26 hours in a day? (Hint: Change the HoursPerDay variable.)]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《American Accent Training》]]></title>
    <url>%2F2017%2F09%2F17%2FAmerican-Accent-Training-01%2F</url>
    <content type="text"><![CDATA[Download links: CD | American Accent Training - Ann Cook track 52 ä a e i ə u̇ ē ō ü ā ī b bä ba beh bih bə bu̇ bē bō bü bā bī ch chä cha cheh chih chə chu̇ chē chō chü chā chī d dä da deh dih də du̇ dē dō dü dā dī f fä fa feh fih fə fu̇ fē fō fü fā fī g gä ga geh gih gə gu̇ gē gō gü gā gī h hä ha heh hih hə hu̇ hē hō hü hā hī j jä ja jeh jih jə ju̇ jē jō jü jā jī k kä ka keh kih kə ku̇ kē kō kü kā kī l lä la leh lih lə lu̇ lē lō lü lā lī m mä ma meh mih mə mu̇ mē mō mü mā mī n nä na neh nih nə nu̇ nē nō nü nā nī p pä pa peh pih pə pu̇ pē pō pü pā pī r rä ra reh rih rə ru̇ rē rō rü rā rī s sä sa seh sih sə su̇ sē sō sü sā sī sh shä sha sheh shih shə shu̇ shē shō shü shā shī t tä ta teh tih tə tu̇ tē tō tü tā tī th thä tha theh thih thə thu̇ thē thō thü thā thī v vä va veh vih və vu̇ vē vō vü vā vī w wä wa weh wih wə wu̇ wē wō wü wā wī y yä ya yeh yih yə yu̇ yē yō yü yā yī z zä za zeh zih zə zu̇ zē zō zü zā zī track 55 ä a e i u̇ ə ē ō ü ā ī ought at etch it um eat oat oops ate i’m b Bob bat bet been book but beat boat boot bait bite ch chop chat check chin chuck cheat choke choose chase child d Don Dad dead did done deal don’t do day die f fawn fat fetch fit foot fun feet phone food fail find g gone gap get give good gun geese go ghoul gate guy h hot had head his hood hut he hold who hey hi j jaw Jack jeff gin jump jeans joke jewel jail giant k call cat Ken kid could come key cold cool cane kite l law laugh left lick look luck lead load lose lay lie m Mom mad men mix much me most moon make mine n not Nan net knit nook none need note new name knife p pot pat pet pick put putt peak pole pool pay pie r raw ran red rib rook rub reed row room raise rise s saw sat said sin soot such see so suit say sigh sh shawl shack shed shill should shut she show shoe shape shine t tall tack ten tin took tub tea toe tube take try th thought that then this the these though through they thigh v Von vat vex vim vug veal voice voodoo veil vie w walk wax when with would was we won’t woo whales why y yamn yap yes yip you’ll young yield yo-yo you Yale yikes z czar zap zen zig zug zeal Zoey zoo zany zygote]]></content>
      <tags>
        <tag>English</tag>
        <tag>American Accent Training</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 learning 01]]></title>
    <url>%2F2017%2F09%2F16%2Fpython3-learning-01%2F</url>
    <content type="text"><![CDATA[lean python3 from now on. In programming, print often means to display text on the screen, instead of printing it on a piece of paper using your printer. 123&gt;&gt;&gt;print('Hello World!')Hello World!&gt;&gt;&gt; pront is not equal to print A keyword is a special word that is part of the Python language (also known as a reserved word). 12345&gt;&gt;&gt;print (3 + 3)6&gt;&gt;&gt;print (5 * 9)45&gt;&gt;&gt; Python can do addition and multiplication! In pretty much all computer programs and languages, the * symbol is used for multiplication. That character is called an asterisk or star. 123&gt;&gt;&gt; print ("cat" + "dog")catdog&gt;&gt;&gt; or: 1234&gt;&gt;&gt; print ("Hello" * 20)Hello Hello Hello Hello Hello Hello Hello Hello Hello HelloHello Hello Hello Hello Hello Hello Hello Hello Hello Hello&gt;&gt;&gt; Besides math, another thing computers are good at is doing things over and over again. Here we told Python to print “Hello” twenty times. Syntax errors Syntax is the spelling and grammar rules for a programming language, so a syntax error means that you have typed something that is not proper Python code. 123print "Hello, and welcome to Python!"print "I hope you will enjoy learning to program."print Bye for now!" We missed a quote mark between print and Bye for now!&quot; If you tried to run this program, it would pop up a message saying “There’s an error in your program: invalid syntax.” Then you would have to look at your code to see what’s wrong. Runtime errors The second kind of error that can happen is one that Python (or IDLE) can’t detect before it runs the program. This kind of error only happens when the program runs, so it is called a runtime error. Here’s an example of a runtime error in a program: 1print ("Hello" + 5) TypeError: cannot concatenate ‘str’ and ‘int’ objects. In Python, we can’t add different kinds of things together, like a number and some text. That’s why print “Bye for now!” + 5 gave us an error. It’s like saying, “If I take 5 apples and add 3 alligators, how many do I have?” we have 8, but 8 of what? Adding these together doesn’t really make sense. But we can multiply almost anything by a number to get more of that kind of thing. (If we have 2 alligators and we multiply by 5, we have 10 alligators!) That’s why print “Bye for now!” * 5 works. Number-guessing game 123456789101112131415161718import randomsecret = random.randint(1, 99)guess = 0tries = 0print ("AHOY! I'm the Dread Pirate Roberts, and I have a secret!")print ("It is a number from 1 to 99. I'll give you 6 tries. ")while guess != secret and tries &lt; 6: guess = input("What's yer guess? ") if guess &lt; secret: print ("Too low, ye scurvy dog!") elif guess &gt; secret: print ("Too high, landlubber!") tries = tries + 1if guess == secret: print ("Avast! Ye got it! Found my secret, ye did!")else: print ("No more guesses! Better luck next time, matey!") print ("The secret number was", secret) Test your knowledge How do you start IDLE? What does print do? What is the symbol for multiplication in Python? What does IDLE display when you start to run a program? What is another word for running a program? Try it out In interactive mode, use Python to calculate the number of minutes in a week. Write a short program to print three lines: your name, your birth date, and your favorite color. The output should look something like this: My name is Warren Sande. I was born January 1, 1970. My favorite color is blue. Save the program and run it. If the program doesn’t do what you expect, or you getany error messages, try to fix it and make it work.]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 15 Reading Passages]]></title>
    <url>%2F2017%2F09%2F16%2FSession-15-Reading-Passages%2F</url>
    <content type="text"><![CDATA[A foreign student When a student from another country comes to study in the United States, he has to find out for himself the answers to many questions, and he has many problems to think about. Where should he live? Would it be better living in a dormitory or in a private room off campus? Should he spend all of his time studying, or should he take advantage of the many cultural and social activities that are offered? At first, he may not feel that he fits in with the American culture. He may not feel confident when he speaks. Little by little, however, he learns how to handle himself in various situations. Finally he begins to feel very secure and ‘at home’. Unfortunately, this long awaited feeling doesn’t develop suddenly. It takes time. Volcanoes Volcanoes are holes in the Earth’s crust which allow molten rock to escape from beneath. The molten rock, or lava, may flow out gently or it may be blasted high in the air with gas and ash in a violent explosion. There are eight hundred and fifty active volcanoes around the world. Do you know where these mountains of fire are found? Three quarters of them are found within a zone called the “Ring of Fire.” One edge of the zone stretches along the west coast of the Americas from Chile to Alaska. The other edge runs along the east coast of Asia from Siberia to New Zealand. Twenty percent of these volcanoes are located in Indonesia. Other big groupings are in Japan, The Aleutian Islands, and Central America. The Chinese Language Chinese is a most unusual language. It differs from English and most other major languages in that it has hundreds of different dialects. A person who lives in one section of the vast country of China, often cannot understand a fellow Chinese who lives in another section. These two major dialects are Cantonese and Mandarin. Cantonese is a southern dialect. Mandarin, a dialect that originated in northern China, is spoken by more Chinese than any other dialect. Non-Chinese people often say that the Chinese seem to “ sing” their language. Chinese sounds as though it is sung, because many words are only one syllable long and because the tone of voice changes for each word. As in English, many words have more than one meaning. The speaker’s tone of voice indicates each word’s specific meaning. Even more fascinating than the variety of spoken sounds is the Chinese written language. It has no alphabet. Instead, it employs signs called “characters.” Each spoken word in the language is represented by a separate character. Originally, the characters were drawings that depicted the meanings of words, but over the years, they have simplified, and most no longer look like the things they represent. The Supercontinent Around 100 to 150 million years ago, there may have been only one continent on our planet. At least that is what some earth scientists have decided after years of research. If you look at the map of the world carefully, you can see that the present day continents could be thought of as the pieces to a gigantic jigsaw puzzle. In your imagination carefully put the pieces together to form the supercontinent. You will see that if you took away the South Atlantic Ocean and pressed South America and Africa together they would fit very nicely. You could continue removing oceans and seas and put other parts of the world together quite easily until you get to those last two pieces of Australia and Antarctica. Scientists believe that the continents of Australia and Antarctica were once linked together. They may have split slowly off from the supercontinent and then separated from each other as recently as 40 million years ago. The 50 Most Mispronounced Words in American English Accounting Argue Actually Available Arrangements Basically Business Calls Complete Continue Contribute Corporation Differences Directly Exactly Educational Every Exceptional Familiar Financial Frustrating General Immediately Inconvenience Introduce Irrational Justice Likeable Loosen Measurements Middle Multiple National Original Outrageous Particular Partnership Problem Prohibit Quality Question Referring Regardless Request Similar Specific Value Visualize Vulnerable Working]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 14 Reading Passages]]></title>
    <url>%2F2017%2F09%2F16%2FSession-14-Reading-Passages%2F</url>
    <content type="text"><![CDATA[Photo album Keeping a family photograph album is a good way to save family memories for yourself and future generations of your family. Very old pictures can be taken to a photo shop and reprinted so that they can be placed in an album. Be sure to write on the back of the picture any information you remember about the people in it. Also, write the date if you remember it. Looking at photo albums is a relaxing way to spend the day and it is a fun activity to share with family and friends. Your children, grandchildren and their children will appreciate your efforts too. The Public Library Your library card can be your ticket to entertainment, current events and new ideas. Almost every city has a public library and there is no charge for a library card. Libraries have books about many subjects, but there are also other things at the library. These include books on cassette tape, video tapes, large print books, CD’s, DVD’s and magazines. Many have free programs in the afternoon or evening about travel, hobbies or other topics of interest. Some cities also have a bookmobile or traveling library, which brings the library right into your neighborhood. John D. Rockefeller John D. Rockefeller did three amazing things. First, he acquired probably the greatest fortune in all history. He started out in life digging potatoes under the hot sun for four cents an hour. In those days, there were not half a dozen men in all the United States who were worth even one million dollars. Eventually, John D. managed to collect a fortune said to be anywhere from one to two billion dollars. And yet, the first girl he fell in love with refused to marry him. The reason given was because her mother refused to allow her daughter to “throw herself away” on a man who had such poor prospects. Stars How many stars can you see on a dark, clear night? You can see about 3,000 stars with your eyes alone. But keep in mind that you are viewing only part of the sky. If the whole sky were visible, you could count about 5,000 stars. If you look through a small telescope you might see as many as 600,000 stars. Through the most powerful telescopes, astronomers can spot millions of stars. No one is sure exactly how many stars there are altogether, but astronomers believe there are at least 200 billion, billion stars out in space. The 10 Keys towards Improvement Number 01. Practice and listen. Number 02. Do not leave off the endings of words. Number 03. Make a list of frequently used words. Number 04. Open your mouth more when you speak English. Number 05. Don’t be afraid to speak. Number 06. Read aloud in English for ten to 15 minutes every day. Number 07. Record your own voice and listen for pronunciation errors. Number 08. Watch the mouth movements of native speakers and imitate them. Number 09. Buy books on tape. Read along with the tape - out loud. Number 10. Be patient.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 13 Phrase Reductions, Intonation]]></title>
    <url>%2F2017%2F09%2F16%2FSession-13-Phrase-Reductions-Intonation%2F</url>
    <content type="text"><![CDATA[Phrase Reductions (Going to try) becomes ‘Gonna try’ I’m gonna try to finish this book. (Want to eat) becomes ‘Wanna eat’ Do you wanna eat at seven o’clock? (Have to start) becomes ‘Hafta start’ I hafta start a diet tomorrow. (Has to try) becomes ‘Hasta try’ He hasta try harder. (Got to leave) becomes ‘Gotta leave’ I really gotta leave in fifteen minutes. (Ought to believe) becomes ‘Oughta believe’ She really oughta believe what he is saying. (Out of bed) becomes ‘outta bed’ I got outta bed when I heard the alarm clock. (Did you go?) becomes ‘Didja go’ Didja go to the store? (Would he help?) becomes ‘Wouldy help’ Wouldy help me move the furniture? (Won’t you play?) becomes ‘Woncha play’ Woncha play one more song on the piano? (Didn’t you know?) becomes ‘Didincha know’ Didincha know that she was coming home tomorrow? (Is he?) becomes ‘Izzy’ Izzy the one that called? (What do you want?) becomes ‘Whadaya want’ (Give it to me.) becomes ‘Gividame’ Gividame right away. Intonation Practice Have you ever tried one of Diane’s Donuts? They are so delicious. I have eaten many different kinds of donuts, from all over the country, however, I have never tasted anything, quite like Donuts made by Diane. I have been told that she uses the finest and freshest ingredients that money can buy. The best flour, the best eggs and the best milk. I am sure, that once you taste these incredible donuts, you will run and tell all of your friends. Syllable Stress Generally, two-syllable words have stress on the first syllable. Two-Syllable Words (stress 1 st syllable) Sofa Oven After Finger Station Second Enter Often Uncle Carpet Father Children Walking Jacket Lucky Comment Two-Syllable Words (stress 2nd syllable) Delete Decline Survive Protect Adopt Advance Below Resolve Advice Acquit Control Arrive Involve Massage Disease Relate Generally, three-syllable words have stress on the second syllable. Three-Syllable Words (stress 2nd syllable) Reduction Arrangement Audition Companion Detective Ambitious Companion Appliance Discover Unlawful Conclusion Assemble Adjustment Affected Acceptance Ferocious Syllable Stress Practice The pictures are fantastic. He needs permission to find a solution. The party is in honor of his retirement. Her son exhibited bad behavior on their vacation. Comparative Sentences Joe drinks cheap wine. Sue only drinks expensive wine. Don’t forget his birthday. We would never forget his birthday. She’s planning to leave tomorrow. He made plans to leave a month ago. The Teacher’s meeting is at 9:00. The students announced that they will never have a meeting. My telephone isn’t working. The telephone needs to work by lunchtime. He’s painting his house blue and green. Your house would look terrible if it were green.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 12 Tongue Twisters]]></title>
    <url>%2F2017%2F09%2F16%2FSession-12-Tongue-Twisters%2F</url>
    <content type="text"><![CDATA[(F, W, Voiced Z) Fuzzy Wuzzy was a bear, Fuzzy Wuzzy had no hair. Fuzzy Wuzzy wasn’t fuzzy, Was he? (Voiced V) Vincent vowed vengeance very viciously. (P) Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked. If Peter Piper picked a peck of pickled peppers, How many peppers did Peter Piper pick? (SH, S and Z) She sells seashells by the seashore. The shells she sells are surely seashells. So if she sells shells on the seashore, I’m sure she sells seashore shells. (W, CH, and Final Consonants) How much wood, would a woodchuck chuck, if a woodchuck could chuck wood? He would chuck, he would, as much as he could, and chuck as much wood as a woodchuck would if a woodchuck could chuck wood. (W) Which witch wished which wicked wish? While we were walking, we were watching window washers wash Washington’s windows with warm washing water. If two witches would watch two watches, which witch would watch which watch? (R) Roberta ran rings around the Roman ruins. (B, BR, and BL blends) Bradley’s big black bathbrush broke. Bradley’s big black bathbrush broke. (TH) Tom threw Tim thirteen thumbtacks. He threw three free throws. There are thirty-three thousand birthdays on the third of every month. The father gathered smooth feathers for Thanksgiving. The sixth graders are enthusiastic about Jonathan’s birthday. (GR, and GL blends) Green glass globes glow greenly. (L, ‘OO’ vowel) Aluminum linoleum (Won’t) I would, if I could! But, I can’t, so I won’t! (Woke) I woke, he woke, she woke, they woke. We all woke up.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 11 AU, AH, A]]></title>
    <url>%2F2017%2F09%2F16%2FSession-11-AU-AH-A%2F</url>
    <content type="text"><![CDATA[‘A’ Vowel Sound Back Dad Fax Value Sat Hatch Jacket Taxi Apple Catch Rabbit Tack ‘A’ Practice The fat cat wore a jacket. Pack your sack and bring your magnet. He sang about an actor named Jack. ‘AU’ Vowel Sound This is an important sound! If mispronounced, it can often make you misunderstood. Begin this sound with the ‘A’ sound as in ‘hat’… Then, slide your mouth forward to form a small ‘W’ sound. Example: ‘Downtown’ » “DA – wn…TA – wn” ‘AU’ Practice Now House Round Loud Gown Sound Ouch Out Found South Ounce Rebound Mouth Bounce Flower Thousand Spout Count The brown couch is downstairs. Her house is on the South side of the mountain. I was proud of the sounds that came out of my mouth. ‘Are’ vs. ‘Our’ Are – Close with strong ‘R’ sound - tongue retracts back Are you going? Our – Begin with the ‘AU’ sound (‘A’ as in Hat), Then close your mouth and say “ Were”. Think of the word ‘Our’ as having two syllables. Pronounced as …“AU-WERE” (The word “Hour” is also pronounced the same way). Are/Our Practice Sentences Are you going to our house? Sales are down, but our projections for next year are very good. Our plans will be changing in the next hour. Are you sure that our meeting will be an hour late? ‘AH’ Vowel Sound ‘O’ words that are pronounced with ‘AH’ Hot Top Stop Probably Follow Not Blob Sock Mop Product Solve Problem ‘AH’ Practice(‘AH’ sounds are underlined) Bob opened the box and followed the instructions. Tom put some cotton, rocks and a doorknob in his locker. His mom made a concrete model of a hockey rink.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 10 OO, UH, EH]]></title>
    <url>%2F2017%2F09%2F16%2FSession-10-OO-UH-EH%2F</url>
    <content type="text"><![CDATA[‘OO’ Vowel Sound Blue Booth News Juice Loosen Ruler Food Choose Mood Moving Loop Knew Tooth Smooth Pool Moon Shoes Zoo Grew Room ‘OO’ Practice The room in the school was very cool. Tuesday at noon in the studio. Viewing the moon on June nights. Do you remember the woman who lived in a shoe? She hadn’t a clue what to do when her family grew. Well, through your help, they are moving in June into two big boots. ‘Double OO’ words that are pronounced as ‘UH’ Food has a high vowel – ‘OO’ Foot has a lower vowel – ‘Uh’ ‘UH’ Vowel Sound (that are spelled with ‘OO’) Foot Took Cook Shook Stood Good Look Book Wool Swoosh Lower vowel – ‘Uh’ Wood Would you help me? Hollywood, California ‘UH’ Practice (‘OO’ sounds are in RED) He took a good look under the hood and found a flute. Julie enjoys good books after school. He put his foot in the new boot. She took her students to the brook to wash their shoes. We pulled him out of the swimming pool. The fool ate until he was full. ‘EH’ Vowel Sounds Egg Get Friend Next Entrance Better Healthy Lettuce Wrench Spread Best Ready Every Red Exit Check Fence Headset Necklace Wealth ‘EH’ Practice Resting on the edge of the bed. Ten letters from the enemy. Dennis will enter the festival. The message was given to the chef. Hello again, friends! Let’s do a weather check. Well, whoever said temperatures are getting better, better get ready to spend a wet weekend in Tennessee.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 9 OW and AE]]></title>
    <url>%2F2017%2F09%2F16%2FSession-9-OW-and-AE%2F</url>
    <content type="text"><![CDATA[Vowel ‘O’ The Hidden ‘W’ “OWE, OWE, OWE, OWE, OWE” ‘O’ Vowel Sound Open Oatmeal Blown Bold Owner Phone Cold Robe Coach Rotate Loan Slow Road Roam ‘O’ Practice How did you know that? I don’t know where the hole is on the coat. Does Joe know how to drive on the road? I need to blow my nose when I have a cold. Has it ever snowed in Rhode Island? Cold winds will slowly blow snow over most of Ohio. This low is no joke. So folks, don’t go out without coats! Woke and Won’t Practice: WOWOWOWOWO Woke = WOW + K Won’t = WOW + ’NT I want the ball. I won’t give you the ball. She wants to sleep. She woke up. He wants to buy a car. He won’t buy a car. They want to speak with you. He won’t speak with you. Vowel ‘AE’ Age Aid Eight Able Chain Date Eighteen Fake Lazy Made Baby Gain Change Gave Nation Day Paper Angel Basic Face ‘AE’ Practice The ape gave the trainer a cane. David began shaving when he was eighteen. The rainbow appeared when daylight changed. The baby snake lived in a painted cage. My neighbor’s basement was changed from blue to beige. Hey, take away the strain! Weigh the gains of a great break with Lazy Day Vacations. Lines are open eight till late. They aim to make your day! The 50 united States (Stressed sounds are in bold) Alabama Hawaii Massachusetts New Mexico South Dakota Alaska Idaho Michigan New York Tennessee Arizona Illinois Minnesota North Carolina Texas Arkansas Indiana Mississippi North Dakota Utah California Iowa Missouri Ohio Vermont Colorado Kansas Montana Oklahoma Virginia Connecticut Kentucky Nebraska Oregon Washington Delaware Louisiana Nevada Pennsylvania West Virginia Florida Maine New Hampshire Rhode Island Wisconsin Georgia Maryland New Jersey South Carolina Wyoming]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 8 Vowel Overview, I and EE]]></title>
    <url>%2F2017%2F09%2F16%2FSession-8-Vowel-Overview-I-and-EE%2F</url>
    <content type="text"><![CDATA[The best way to learn American vowels is by Ear Training. Listen carefully and repeat. Front Vowels:(From high to low) EE - as in Heat I - as in Hit AE - as in Hate EH - as in Het (nonsense word) A - as in Hat Back Vowels: (From high to low) OO - as in Boot U - as in Book OW - as in Boat AW - as in Bought AH - as in Bot (nonsense word) Comparing Heat (EE) and Hit (I) Remember,… Heat is high Hit is lower Heat – Hit Keen – Kin Deal – Dill Seek – Sick Seen – Sin Reap – Rip Teal - Till Bean –Been Bean – I ate a bean (noun). – ‘high’ Been – I have been here (verb). – ‘low’ ‘EE’ Vowel Sound …remember, smile and think high See Me Each Even Key Green Tree Very Happy Softly Mary Busy Finally Country ‘EE’ Practice Speeding on the Freeway Happily eating cheese He and She Skiing very Rapidly She sees a monkey eating honey. We see a pony stealing money. Who can he see? It must be me! ‘I’ Vowel Sound Bit Bill Lift Fizz Kitchen Build Bigger Chimp Fifth Listen Business Fist Display Filming Live Fish Discuss Fig Fifty Been ‘EE’ and ‘I’ Practice (All ‘EE’ sounds are underlined.) The beans have been cooking since six o’clock. Sit in that seat by the window. We ate our meal, by the mill. The seal will live in the ocean. Tim’s team grinned after seeing the green field . Pip and Pete shipped the sheep cheaply. Those bins are for Bill’s beans. Does Jim still steal Jill’s Jeans? The girls put concrete on Jill’s sneakers. Pick cherries at their peak or you will eat the pits.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 7 DG and Ch, H]]></title>
    <url>%2F2017%2F09%2F16%2FSession-7-DG-and-Ch-H%2F</url>
    <content type="text"><![CDATA[‘CH’ sound ‘Ch’ at the beginning of words China Cherry Charge Chocolate Challenge Cheese Chunk Chairman ‘Ch’ in the middle of words Key chain Lunch box Richard Picture Teacher Fortune Nature Beach ball ‘Ch’ at the end of words Detach Teach Porch March Patch Wrench Coach Approach ‘Ch’ exercise Chop-chop, children, it’s Charlie’s Kitchen adventure! Today, Chuck will be teaching future champion cooks how to make a chocolate cheesecake. ‘The American J’ sound (DG) ‘American J’ at the beginning of words Juice Jump Juggle Jury Japan Giant Genetic Junior Generate German ‘American J’ in the middle of words Algebra Legend Magic Subject Digest Rejoice Objective Majesty Educate Suggestion ‘American J’ at the end of words Age College Postage Stage Pledge Village Average Page Courage Knowledge ‘American J’ exercise A German judge and jury have charged and jailed a strange giant, who sat on the edge of a bridge throwing jelly onto large barges. Consonant ‘H’ When an ‘H’ is at the beginning of a word it is pronounced with a strong, loud air-stream. Practice: Ha… Ha… Ha. ‘H’ at the beginning of words Hand Hide Hope Hair House Harvard Honey Happy Who Whole ‘H’ word pairs Old Hold Is His It Hit At Hat Arm Harm Ill Hill Ate Hate As Has ‘H’ in the middle of words Ahead Behave Anyhow Inhale Downhill Dehydrate Wholehearted Overhaul ‘H’ exercise He thought that he should…… ……wash the car. ……thank his teacher. ……watch television. ……use the telephone. ……shut the door. ……breathe deeply. (Voiced TH) ……tell the truth. Henry the hungry hippo, who hogged a huge heap of one hundred hamburgers, has had hiccups for one whole week.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 6 Word Endings]]></title>
    <url>%2F2017%2F09%2F16%2FSession-6-Word-Endings%2F</url>
    <content type="text"><![CDATA[Make sure that the final sounds in your words come through clearly and fully. Don’t drop off or shorten the endings! ‘P’ endings I hope the group will sleep on the ship. The soda pop spilled out of the cup, over the map and onto her lap. Was the egg drop soup cheap? ‘B’ endings We cleaned the cobweb from the doorknob near the bathtub. Rob broke his golf club when he slipped on the ice cube. The crab was under the cement slab at the yacht club. The ticket stub was found in the taxi cab. ‘T’ endings Kate left her cat on the mat as she flew a kite. The sailboat came into the port to join the fleet. What bait will make the fish bite? A cricket or a piece of meat? ‘D’ endings Fred will decide which sled should be painted red. David tried to send a refund back to England. He could not hide his report card behind the chalk board. Three rules for ‘–ed’ endings Manseny verbs that are in the past te, end in ‘–ed’. (Example: “Today I walk, yesterday I walked”) Rule #1 If a word ends in an unvoiced consonant, when adding ‘-ed’, just add an Unvoiced ‘T’ Example: Today I jump, yesterday I jumped. (pronounced jump-T) Today I walk, yesterday I walked. (pronounced walk-T) Rule #2 If a word ends in a voiced consonant, add a Voiced ‘D’ Example: Today I rub, yesterday I rubbed. (pronounced rub-D) I cleaned the kitchen. I poured the milk. I scrubbed the floor. I tagged the clothing. I spilled some juice. I trimmed the tree. I moved to California. The clock buzzed all night. Rule #3 If a word ends in a ‘T’ or a ‘D’ sound, we add a Voiced ‘ID’ Example: Today, I lift the ball. Yesterday, I lifted the ball. I heated up my dinner. He voted this morning. He handed me his report. I traded in my old car. She added some information. If you have a color printer, notice that all voiced ‘D’ endings are in the color Red to help you remember to add voicing. Bob raked the leaves and then started to wash his car. He then loaded up the dishwasher and finished washing his dishes. Susan spilled her drink on the spotted rug. She cleaned it up with a napkin, which wasted a lot of time. He thanked me and offered me money, if I picked up the used equipment. 3 Nasal Sounds ‘M’ ‘N’ ‘NG’ practice –ng endings Ring Sing Thing Bring practice sentences I have a feeling that she is working too much. She has been wearing a hearing aid so that she could sing. He is looking forward to speaking at the Thanksgiving celebration.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 5 L]]></title>
    <url>%2F2017%2F09%2F16%2FSession-5-L%2F</url>
    <content type="text"><![CDATA[Things to remember when making an American ‘L’ sound… Your bottom jaw should be as wide open as possible. Your tongue should RISE UP (independently of your jaw) and touch right behind your top teeth. Produce the ‘L’ sound by dropping and relaxing your tongue. Practice “LA, LA, LA”, keeping your bottom jaw lowered and open while only raising your tongue. ‘L’ at the beginning of words Lunch Local London Learn Large Life Lobby Library Lucky Lift Laugh Long ‘L’ in the middle of words Inflation Believe Volume Glue Elevator Solve Pulling Flood Delete Elect Alive Color ‘L’ at the end of a word To produce an ‘L’ at the end of a word, remember to slowly raise your tongue upward, towards your upper teeth, while keeping your bottom jaw as open as possible. The ‘L’ sound comes from the tongue movement, not from the placement. (Using your finger to push down on your bottom teeth to keep your jaw open, may be helpful for practicing.) Practice words Will Apple Ball Miracle Tall Powerful Call Control Small Financial Control People Bowl ‘L’ Sentences The lollipop fell into the cool water. Her driver’s license was pulled out of the blue golf bag. Blake’s bowling ball fell under his tools. Carl could not locate the lemons or the limes. The school was a mile away from the hill. The golf club was made of steel. Al’s goal was to play baseball with Carol. A certified letter was delivered for the enrollment list. It was revealing to look at the smiling lawyer. ‘FL’ Blend Poem A flea and a fly, flew up in a flue. Said the flea, “Let us fly!” Said the fly, “Let us flee!” So they flew through a flaw in the flue. Practice using ‘Will’ Will you empty the garbage? Will you ask her to clean the kitchen? Will you prepare a meal for the children? When will you begin your studies at college? When will she purchase the dress for her wedding? Why will he ask them to stay late at work? Why will she bring her baby to the meeting? How will they know if our flight is delayed? Where will the child be going next year? Where will they put all of the pillows? What will she do with the millions of dollars she won? Comparing ‘R’ and ‘L’ Red - Led Rick - Lick Reef - Leaf Rear - Lear Rest - Less Grass - Glass Crime - Climb Free - Flee ‘L’ and ‘R’ Combinations seal ring toll road already civil rights railroad rivalry coral reef jewelry school room gravel road]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 4 F and V, Sh and Voiced SH]]></title>
    <url>%2F2017%2F09%2F16%2FSession-4-F-and-V-Sh-and-Voiced-SH%2F</url>
    <content type="text"><![CDATA[Consonants ‘F’ and ‘V’ Consonants ‘F’ and ‘V’ are produced with contact of your upper teeth and lower lip. Think of it as “biting your lower lip”. Maintain a steady air stream. They are both identical, except the ‘F’ is unvoiced, and the ‘V’ is voiced. Correct voicing will make your speech clearer and more intelligible. Practice Words with ‘F’ Foot Find Finally Family Freedom Laugh Telephone Symphony Rough Practice Sentences Do you feel like a physical wreck? Are you fed up with your feeling of fatigue? Have you had enough of feeling rough? Why don’t you fight fever with Pharaoh’s Friend. A medicine that is tough on Flu. Practice Words with ‘V’ Vote Vine Oven Evaluate Voice Travel River Every Glove Alive Leave Comparing ‘F’ and ‘V’ Feel – Veal Safe – Save Fat – Vat Fine – Vine Face – Vase Fan – Van Foul – Vowel Proof – Prove Practice Phrases A famous athlete A food vendor The Foreign Service Summer vacation Vocabulary test Over the rainbow Our first victory Harvard University Husband and wife Very well done Practice Sentences Her promotion in the firm was well deserved. There was only one survivor on the island. Steve noticed that the olive juice must have stained his sleeve. The street vendor was selling souvenirs to tourists. Dave gave me his car so that I could drive on New Year’s Eve. There were several dents in the rear fender. Tom placed several tomatoes from the vine into a basket. The Unvoiced ‘SH’ Sound To make the Unvoiced ‘SH’ sound, bring your mouth and lips forward, teeth should be slightly apart. Produce air stream. Words beginning with ‘SH” begin with this sound. (So are the words “Sugar”, “Sure”, “Chef” and “Chicago”.) ‘SH’ practice words Beginning Middle End She Nation Rush Sugar Motion Dish Sure Mission Establish Shadow Special Splash Sheep Reputation Irish Shirt Official Fresh Shoe Machine Finish Shape Fishing Chicago Insurance Chef Sunshine Ocean Tissue Addition Subtraction ‘SH’ Sentences The fishing trip was planned and we left to go to the ocean. Was the chef ashamed to use the precious sugar? Sharon gave a special performance. He will be stationed in Washington, D.C, the nation’s capital. She went to a fashion show after taking a shower. She sells seashells by the seashore. The social club was praised for their cooperation. ‘SH’ Practice Joe’s weather machine shows a sharp drop in air pressure, especially offshore. Ships in motion on the ocean should be sure to use caution. The Voiced ‘ZSH’ Sound The Voiced ‘ZSH’ sound is exactly like the ‘SH’ except voicing is added. This is an important sound in American English. ‘ZSH’ practice words Middle End Usual Beige Unusual Massage Usually Prestige Vision Visual Conclusion Asia Version Division Casual Television Practice Sentences It’s not unusual for people to study division in Asia. I usually use a measuring cup to measure erosion. The beige walls were the usual color in the treasury building. List things that are appropriate for each column. Then say them out loud in full sentences for practice. Example: “It’s usually hot in the summer.” “It’s unusual for me to be late for an appointment.”]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 3 TH, Voiced T]]></title>
    <url>%2F2017%2F09%2F16%2FSession-3-TH-Voiced-T%2F</url>
    <content type="text"><![CDATA[The ‘Unvoiced TH’ Sound Flat tongue protruding through your teeth. Maintaina steady air stream. Stretch outthe ‘TH’ sound. Example: Think of the word “Thumb” as having two beats Th » umb 1 » 2 ‘TH’ practice words Beginning Middle End Thanks Anything Bath Thick Bathmat North Thunder Toothpick Beneath Thursday Athletic Fourth Think Mouthwash South The ‘Voiced TH’ Sound Voiced ‘TH’ at the beginning of words The (The book) That (That house) They (They came over) Them (Give them water) There (There it is) This (This is my nose) Those (Those boys are good) These (These are my parents) Voiced ‘TH’ in the middle of words Clothing Leather Mother Another Weather NorthernSession Voiced ‘TH’ at the end of words Smooth Bathe Breathe Practice Phrases This and that A tablecloth Winter clothing Athens, Greece That’s the one Her skin is smooth Thirty Day’s notice A famous author Here and there False teeth Thread the needle A thoughtful gift Thunder and lightening Thumbs up Practice Sentences Thelma arrived in town last Thursday. I’m having trouble threading this needle. I need 33 thick thermometers. The thing they like best about Athens is the weather. This thrilling novel was written by a famous author. He will be through with his work at three-thirty. Now and then, she likes to buy new clothing. They thought they were going to Northern Spain. Which tablecloth shall we use for the party? That was the thirty-third theatre to open. THR Blends Thread “Thread the needle.” Throw “Throw the ball.” Throat “My throat is sore.” Thrill “A thrilling ride.” Three “Three more days.” Threw “Yesterday, he threw the ball.” Throne “The king sits on a throne.” Paragraph Practice Nurse Thatcher was thankful it was Thursday. She knew that on Thursday she had to deliver 33 boxes of thermometers to the North American Athletic Club. They thought that thermometers were necessary for testing the hydrotherapy baths. This was thought to benefit the athletes with arthritis. The athletic trainers required authorization to provide hydrotherapy to the youthful athletes on the three bulletin boards with thumbtacks throughout the athletic club. Rather than risk the health of the athletes, they thoroughly checked the thousands of thermometers to ensure their worthiness; otherwise they needed to be thrown away. “TH” Exceptions Although the following words are spelled with a ‘TH’, they are pronounced as a ‘T’: Thomas Thompson Theresa Thailand Thames Esther Thyme Voicing the ‘T’ Sound If a ‘T’ falls within two voiced sounds (usually vowels), the ‘T’ becomes voiced like a ‘D’. Examples: Water » Wader(the whole word is voiced) Better » Bedder Butter » Budder Voiced ‘T’ Practice Betty bought a bit of better butter. But, said she, This butter’s bitter. If I put it in my batter, It’ll make my batter bitter.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 2 Voicing, S and Z]]></title>
    <url>%2F2017%2F09%2F15%2FSession-2-Voicing-S-and-Z%2F</url>
    <content type="text"><![CDATA[Paired Consonants: Unvoiced Voiced P » B T » D F » V SH » ZSH K » G S » Z Three rules for S/Z endings This is easier than it looks! Rule #1 If a word ends in a sound that is unvoiced (such as P,T,K,F), you add an unvoiced /S/ Examples: 1 cup 2 cups 1 cat 2 cats I break He breaks I stop He stops Rule #2 If a word ends in any of these sounds: ‘s z sh ch dg (j)’ when adding an ‘S’ ending, add… IZZZZZZ Examples: 1 Page 2 Pages 1 Bus 2 Buses 1 Lunch 2 Lunches I Raise He Raises I Brush He Brushes I Push He Pushes Rule #3 If a word ends in a vowel sound (like the word Tree) or a voiced consonant (like the word Game), then when you add an ‘S’, continue the voicing throughout the entire word, and it should become a voiced ZZZZ. Examples: 1 Tree 2 Treezzzz (correctly spelled Trees) 1 Day 2 Days 1 Shoe 2 Shoes I Fly He Flies 1 Game 2 Games 1 Head 2 Heads 1 Train 2 Trains 1 Song 2 Songs Some common words where S’s are pronounced as Z’s IS HIS AS WAS THESE THOSE EASY BECAUSE Paragraph Practice If you have a color printer, notice that all voiced S/Z sounds are in the color Red to help you remember to add voicing. Another zippy, zappy, crazy day comes to a close. As we zoom up to Joe’s snooze zone, Zoe Jones of Zodiac Zoo plays with her zipper. Last week, Jim’s brothers were picked to represent their country in the Olympic Games. Two of the brothers were swimmers, while the other two were long distance runners. All of the brothers wore glasses. These athletes worked hard at qualifying for the games and were hoping to come home with prizes. Since the brothers go to the same university, they often take the same courses. This makes studying easier and gives them more time to do other things. On Thursday, I had a very lazy day. I woke up early and first squeezed oranges into juice. I then got dressed and watched the sunrise come up over the mountains. It was so beautiful that I took many pictures with my camera and I used three rolls of film. After drinking two cups of coffee, I got dressed, left the house, and walked three miles home.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session 1 R and W]]></title>
    <url>%2F2017%2F09%2F15%2FSession-1-R-and-W%2F</url>
    <content type="text"><![CDATA[Consonant ‘R’ Two things to remember when making an American ‘R’ sound… Your mouth and lips come forward, like you are going to kiss. Your tongue moves back in your mouth, NOT forward. ‘R’ at the beginning of words Rock Rip Reach Road Rain Rich Rome Raise Robe Rice ‘R’ Sentence The round rooster rushed into the wrong road. ‘R’ at the end of words or after a vowel Car Far Star Door Bear Four Air Year Turn Poor ‘R’ in the middle of words Very Direction Arrange Erase Correct Marry Garage Original Hurry Zero Marine Berry Operation Caring Arrive Everyone R’ Blends Remember… ‘R’ is the strongest sound of the blend. When the blend is at the beginning of a word, your mouth prepares for the ‘R’, by coming forward before you even say the word. ‘R’ blends at the beginning of words Training Trust Trip Great Bring Tropical Print President Product Cracker Crawl Break ‘R’ blends in the middle of words Subtract Waitress Nutrition Australia Introduce Compress Oppression Betray ‘R’ practice sentences The story he read on the radio was incorrect. Her career in the law firm is permanent. Richard and Brooke took a ride in their brand new Range Rover truck. Everyone will respect the Royal Family when they arrive at the airport. The trip to the Rocky Mountains will be rescheduled on Friday. Consonant ‘W’ Practice first with » ‘OO’ then go into » ‘OOOOOWAWAWA’ Remember, A “W” is always makes a “W” sound. It NEVER makes a “V” sound. ‘W’ Sentence What will we do? Comparing ‘R’ and ‘W’ Rick – Wick Right – White Remember, the ‘W’ sound is also at the beginning of the words One and Once. ‘W’ at the beginning of words Why Which When What Wipe Wish Weight Wing ‘W’ in the middle of words Always Away Beware Awake Rewind Someone Halloween Hollywood ‘W’ practice sentences The wind from the west was very wet. (Notice very has a /v/ sound) We woke up and washed the white washcloth. We waited for the waitress to give us water. We had a wonderful time in Washington and Wisconsin. ‘Q’ words (produced as a KW sound) Question Quiet Queen Qualify Quit Quebec Quilt Choir Paragraph Practice Word Review Ray Russia Dreamed Roller Coaster Grand Canyon Arizona Friend Fred Norway Railroad Traveling Creative Perfect Construct Everyone Ray was born in Russia. He dreamed of building the perfect roller coaster at the Grand Canyon in Arizona. He had a friend named Fred who lived in Norway. Fred’s profession was designing railroad tracks and his career involved traveling all around the world. Ray thought it would be perfect if Fred designed his roller coaster ride. Fred was creative, brilliant and worked well with railroad tracks. He would be the perfect engineer for the project. The ride took two years to construct and was painted red and white. Everyone really wanted to ride the brand new roller coaster.]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO常用命令]]></title>
    <url>%2F2017%2F09%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[HEXO常用命令 hexo new “postName” # 新建文章 hexo new page “pageName” # 新建页面 hexo clean # 清除之前 public 文件夹的内容 hexo generate # 生成静态页面至public目录 hexo deploy # 将.deploy目录部署到GitHub hexo server # 开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo help # 查看帮助 hexo version # 查看HEXO的版本 简写指令 hexo n == hexo new hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo v == hexo version]]></content>
      <categories>
        <category>computer</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
